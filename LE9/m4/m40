#!/usr/bin/env python3
"""mem2log"""

from argparse import ArgumentParser
from ctypes import CDLL
from signal import SIGHUP, SIGINT, SIGQUIT, SIGTERM, signal
from sys import exit
from time import sleep

import gc

gc.disable()



def log(msg):
    """
    """
    print(msg)
    if separate_log:
        logging.info(msg)


def mlockall():
    """
    """
    MCL_CURRENT = 1
    MCL_FUTURE = 2
    MCL_ONFAULT = 4

    libc = CDLL(None, use_errno=True)
    result = libc.mlockall(MCL_CURRENT | MCL_FUTURE | MCL_ONFAULT)

    if result != 0:
        result = libc.mlockall(MCL_CURRENT | MCL_FUTURE)
        if result != 0:
            log('WARNING: cannot lock process memory: [Errno {}]'.format(
                result))
        else:
            log('Process memory locked with MCL_CURRENT | MCL_FUTURE')
    else:
        log('Process memory locked with MCL_CURRENT | MCL_FUTURE | MCL_'
            'ONFAULT')


def check_meminfo():
    """
    """
    # MA MF BU CA AA IA AF IF ST SF DI WR SH SR
    gc.collect()
    with open('/proc/meminfo') as f:
        for n, line in enumerate(f):

            # MA
            if n == mem_available_index:
                mem_available = int(line.split(':')[1][:-4])
                continue

            # MF
            if n == mem_free_index:
                mem_free = int(line.split(':')[1][:-4])
                continue

            # BU
            if n == buffers_index:
                buffers = int(line.split(':')[1][:-4])
                continue

            # CA
            if n == cached_index:
                cached = int(line.split(':')[1][:-4])
                continue

            # AA
            if n == active_anon_index:
                active_anon = int(line.split(':')[1][:-4])
                continue

            # IA
            if n == inactive_anon_index:
                inactive_anon = int(line.split(':')[1][:-4])
                continue

            # AF
            if n == active_file_index:
                active_file = int(line.split(':')[1][:-4])
                continue

            # IF
            if n == inactive_file_index:
                inactive_file = int(line.split(':')[1][:-4])
                continue

            # ST
            if n == swap_total_index:
                swap_total = int(line.split(':')[1][:-4])
                continue

            # SF
            if n == swap_free_index:
                swap_free = int(line.split(':')[1][:-4])
                continue

            # DI
            if n == dirty_index:
                dirty = int(line.split(':')[1][:-4])
                continue

            # WR
            if n == writeback_index:
                writeback = int(line.split(':')[1][:-4])
                continue

            # WR
            if n == isf_index:
                isf = int(line.split(':')[1][:-4])
                continue






            # SH
            if n == shmem_index:
                shmem = int(line.split(':')[1][:-4])
                continue

            # SR
            if n == sreclaimable_index:
                sreclaimable = int(line.split(':')[1][:-4])
                continue

    return (
        mem_available,
        mem_free,
        buffers,
        cached,
        active_anon,
        inactive_anon,
        active_file,
        inactive_file,
        swap_total,
        swap_free,
        dirty,
        writeback,
        isf,
        shmem,
        sreclaimable)


def percent(num):
    """Interprete num as percentage."""
    return round(num * 100, 1)


def signal_handler(signum, frame):
    """
    """
    def signal_handler_inner(signum, frame):
        pass

    for i in sig_list:
        signal(i, signal_handler_inner)

    log('--')

    log('Got the {} signal'.format(
        sig_dict[signum]))

    log('Peak values:')

    log('  MA: min {}, max {}'.format(
        round(min_dict['MA'] / 1024, 1),
        round(max_dict['MA'] / 1024, 1)))

    log('  MF: min {}, max {}'.format(
        round(min_dict['MF'] / 1024, 1),
        round(max_dict['MF'] / 1024, 1)))

    if mode == '1':

        log('  A:  min {}, max {}'.format(
            round(min_dict['A'] / 1024, 1),
            round(max_dict['A'] / 1024, 1)))

        log('  F:  min {}, max {}'.format(
            round(min_dict['F'] / 1024, 1),
            round(max_dict['F'] / 1024, 1)))

        log('  AF: min {}, max {}'.format(
            round(min_dict['AF'] / 1024, 1),
            round(max_dict['AF'] / 1024, 1)))

        log('  IF: min {}, max {}'.format(
            round(min_dict['IF'] / 1024, 1),
            round(max_dict['IF'] / 1024, 1)))

        log('  D:  min {}, max {}'.format(
            round(min_dict['D'] / 1024, 1),
            round(max_dict['D'] / 1024, 1)))



        log('  C:  min {}, max {}'.format(
            round(min_dict['C'] / 1024, 1),
            round(max_dict['C'] / 1024, 1)))




        log('  SF: min {}, max {}'.format(
            round(min_dict['SF'] / 1024, 1),
            round(max_dict['SF'] / 1024, 1)))

    else:

        log('  BU: min {}, max {}'.format(
            round(min_dict['BU'] / 1024, 1),
            round(max_dict['BU'] / 1024, 1)))

        log('  CA: min {}, max {}'.format(
            round(min_dict['CA'] / 1024, 1),
            round(max_dict['CA'] / 1024, 1)))

        log('  AA: min {}, max {}'.format(
            round(min_dict['AA'] / 1024, 1),
            round(max_dict['AA'] / 1024, 1)))

        log('  IA: min {}, max {}'.format(
            round(min_dict['IA'] / 1024, 1),
            round(max_dict['IA'] / 1024, 1)))

        log('  AF: min {}, max {}'.format(
            round(min_dict['AF'] / 1024, 1),
            round(max_dict['AF'] / 1024, 1)))

        log('  IF: min {}, max {}'.format(
            round(min_dict['IF'] / 1024, 1),
            round(max_dict['IF'] / 1024, 1)))

        log('  SF: min {}, max {}'.format(
            round(min_dict['SF'] / 1024, 1),
            round(max_dict['SF'] / 1024, 1)))

        log('  SU: min {}, max {}'.format(
            round(min_dict['SU'] / 1024, 1),
            round(max_dict['SU'] / 1024, 1)))

        log('  DI: min {}, max {}'.format(
            round(min_dict['DI'] / 1024, 1),
            round(max_dict['DI'] / 1024, 1)))

        log('  CF: min {}, max {}'.format(
            round(min_dict['CF'] / 1024, 1),
            round(max_dict['CF'] / 1024, 1)))

        log('  SH: min {}, max {}'.format(
            round(min_dict['SH'] / 1024, 1),
            round(max_dict['SH'] / 1024, 1)))

        log('  SR: min {}, max {}'.format(
            round(min_dict['SR'] / 1024, 1),
            round(max_dict['SR'] / 1024, 1)))

    log('Exit.')

    exit()


parser = ArgumentParser()

parser.add_argument(
    '-i',
    '--interval',
    help="""interval in sec""",
    default=2,
    type=float
)


parser.add_argument(
    '-l',
    '--log',
    help="""path to log file""",
    default=None,
    type=str
)


parser.add_argument(
    '-m',
    '--mode',
    help="""mode (1 or 2)""",
    default='1',
    type=str
)


args = parser.parse_args()
interval = args.interval
log_file = args.log
mode = args.mode


if log_file is None:
    separate_log = False
else:
    separate_log = True
    import logging

if log_file is not None:
    logstring = 'log file: {}, '.format(log_file)
else:
    logstring = 'log file is not set, '


if separate_log:
    try:
        logging.basicConfig(
            filename=log_file,
            level=logging.INFO,
            format="%(asctime)s: %(message)s")
    except Exception as e:
        print(e)
        exit(1)


if interval <= 0:
    log('error: argument -i/--interval: the value must be greater than 0')
    exit(1)


with open('/proc/meminfo') as f:
    mem_list = f.readlines()


mem_list_names = []

for s in mem_list:
    mem_list_names.append(s.split(':')[0])


mem_available_index = mem_list_names.index('MemAvailable')
mem_free_index = mem_list_names.index('MemFree')
buffers_index = mem_list_names.index('Buffers')
cached_index = mem_list_names.index('Cached')
active_anon_index = mem_list_names.index('Active(anon)')
inactive_anon_index = mem_list_names.index('Inactive(anon)')
active_file_index = mem_list_names.index('Active(file)')
inactive_file_index = mem_list_names.index('Inactive(file)')
swap_total_index = mem_list_names.index('SwapTotal')
swap_free_index = mem_list_names.index('SwapFree')
dirty_index = mem_list_names.index('Dirty')
writeback_index = mem_list_names.index('Writeback')

isf_index = mem_list_names.index('Isolated(file)')





shmem_index = mem_list_names.index('Shmem')
sreclaimable_index = mem_list_names.index('SReclaimable')


mem_total = int(mem_list[0].split(':')[1][:-4])
swap_total = int(mem_list[swap_total_index].split(':')[1][:-4])


sig_list = [SIGTERM, SIGINT, SIGQUIT, SIGHUP]

sig_dict = {
    SIGINT: 'SIGINT',
    SIGQUIT: 'SIGQUIT',
    SIGHUP: 'SIGHUP',
    SIGTERM: 'SIGTERM'
}

for i in sig_list:
    signal(i, signal_handler)


if not (mode == '1' or mode == '2'):
    print('ERROR: invalid mode. Valid values are 1 and 2. Exit.')
    exit(1)


log('Starting mem2log with interval {}s, mode: {}'.format(interval, mode))


if separate_log:
    log('Log file: {}'.format(log_file))


mlockall()

log('All values are in mebibytes')

log(
    'MemTotal: {}, SwapTotal: {}'.format(
        round(mem_total / 1024, 1),
        round(swap_total / 1024, 1)
    )
)

log('--')


min_dict = dict()
max_dict = dict()


if mode == '2':

    log(
        'MA is MemAvailable, '
        'MF is MemFree, '
        'BU is Buffers, '
        'CA is Cached'
    )

    log(
        'AA is Active(anon), '
        'IA is Inactive(anon), '
        'AF is Active(file), '
        'IF is Inactive(file)'
    )

    log(
        'SF is SwapFree, '
        'SU is `SwapTotal - SwapFree`, '
    )

    log(

        'DI is Dirty, '
        'CF is Clean File (AF + IF - DI), '
        'SH is Shmem, '
        'SR is SReclaimable'
    )

    log('--')

    while True:

        (mem_available, mem_free, buffers, cached, active_anon, inactive_anon,
         active_file, inactive_file, swap_total, swap_free, dirty, shmem,
         sreclaimable) = check_meminfo()

        swap_used = swap_total - swap_free
        clean_file = max(0, (active_file + inactive_file - dirty))

        if ('MA' not in max_dict or mem_available > max_dict['MA']):
            max_dict['MA'] = mem_available
        if ('MA' not in min_dict or mem_available < min_dict['MA']):
            min_dict['MA'] = mem_available

        if ('MF' not in max_dict or mem_free > max_dict['MF']):
            max_dict['MF'] = mem_free
        if ('MF' not in min_dict or mem_free < min_dict['MF']):
            min_dict['MF'] = mem_free

        if ('BU' not in max_dict or buffers > max_dict['BU']):
            max_dict['BU'] = buffers
        if ('BU' not in min_dict or buffers < min_dict['BU']):
            min_dict['BU'] = buffers

        if ('CA' not in max_dict or cached > max_dict['CA']):
            max_dict['CA'] = cached
        if ('CA' not in min_dict or cached < min_dict['CA']):
            min_dict['CA'] = cached

        if ('AA' not in max_dict or active_anon > max_dict['AA']):
            max_dict['AA'] = active_anon
        if ('AA' not in min_dict or active_anon < min_dict['AA']):
            min_dict['AA'] = active_anon

        if ('IA' not in max_dict or inactive_anon > max_dict['IA']):
            max_dict['IA'] = inactive_anon
        if ('IA' not in min_dict or inactive_anon < min_dict['IA']):
            min_dict['IA'] = inactive_anon

        if ('AF' not in max_dict or active_file > max_dict['AF']):
            max_dict['AF'] = active_file
        if ('AF' not in min_dict or active_file < min_dict['AF']):
            min_dict['AF'] = active_file

        if ('IF' not in max_dict or inactive_file > max_dict['IF']):
            max_dict['IF'] = inactive_file
        if ('IF' not in min_dict or inactive_file < min_dict['IF']):
            min_dict['IF'] = inactive_file

        if ('SF' not in max_dict or swap_free > max_dict['SF']):
            max_dict['SF'] = swap_free
        if ('SF' not in min_dict or swap_free < min_dict['SF']):
            min_dict['SF'] = swap_free

        if ('SU' not in max_dict or swap_used > max_dict['SU']):
            max_dict['SU'] = swap_used
        if ('SU' not in min_dict or swap_used < min_dict['SU']):
            min_dict['SU'] = swap_used

        if ('DI' not in max_dict or dirty > max_dict['DI']):
            max_dict['DI'] = dirty
        if ('DI' not in min_dict or dirty < min_dict['DI']):
            min_dict['DI'] = dirty

        if ('CF' not in max_dict or clean_file > max_dict['CF']):
            max_dict['CF'] = clean_file
        if ('CF' not in min_dict or clean_file < min_dict['CF']):
            min_dict['CF'] = clean_file

        if ('SH' not in max_dict or shmem > max_dict['SH']):
            max_dict['SH'] = shmem
        if ('SH' not in min_dict or shmem < min_dict['SH']):
            min_dict['SH'] = shmem

        if ('SR' not in max_dict or sreclaimable > max_dict['SR']):
            max_dict['SR'] = sreclaimable
        if ('SR' not in min_dict or sreclaimable < min_dict['SR']):
            min_dict['SR'] = sreclaimable

        log(
            'MA {}, MF {}, BU {}, CA {}, AA {}, IA {}, AF {}, IF {}, '
            'SF {}, SU {}, DI {}, CF {}, SH {}, SR {}'.format(
                round(mem_available / 1024),
                round(mem_free / 1024),
                round(buffers / 1024),
                round(cached / 1024),
                round(active_anon / 1024),
                round(inactive_anon / 1024),
                round(active_file / 1024),
                round(inactive_file / 1024),
                round(swap_free / 1024),
                round(swap_used / 1024),
                round(dirty / 1024),
                round(clean_file / 1024),
                round(shmem / 1024),
                round(sreclaimable / 1024)
            ))

        sleep(interval)





# 1

log('MA is MemAvailable, MF is MemFree, A is Anon')
log('F is File, AF is Active(file), IF is Inactive(file)')
log('D is Dirty, C is Clean file (File - Dirty), SF is SwapFree')
log('--')

while True:
    # MA MF BU CA AA IA AF IF ST SF DI WR SH SR
    (mem_available, mem_free, _, _, active_anon, inactive_anon, active_file,
     inactive_file, swap_total, swap_free, dirty, _, isf, _, _) = check_meminfo()

    anon = active_anon + inactive_anon
    total_file = active_file + inactive_file
    clean = total_file - dirty

    if ('MA' not in max_dict or mem_available > max_dict['MA']):
        max_dict['MA'] = mem_available
    if ('MA' not in min_dict or mem_available < min_dict['MA']):
        min_dict['MA'] = mem_available

    if ('MF' not in max_dict or mem_free > max_dict['MF']):
        max_dict['MF'] = mem_free
    if ('MF' not in min_dict or mem_free < min_dict['MF']):
        min_dict['MF'] = mem_free

    if ('A' not in max_dict or anon > max_dict['A']):
        max_dict['A'] = anon
    if ('A' not in min_dict or anon < min_dict['A']):
        min_dict['A'] = anon

    if ('F' not in max_dict or total_file > max_dict['F']):
        max_dict['F'] = total_file
    if ('F' not in min_dict or total_file < min_dict['F']):
        min_dict['F'] = total_file

    if ('AF' not in max_dict or active_file > max_dict['AF']):
        max_dict['AF'] = active_file
    if ('AF' not in min_dict or active_file < min_dict['AF']):
        min_dict['AF'] = active_file

    if ('IF' not in max_dict or inactive_file > max_dict['IF']):
        max_dict['IF'] = inactive_file
    if ('IF' not in min_dict or inactive_file < min_dict['IF']):
        min_dict['IF'] = inactive_file

    if ('SF' not in max_dict or swap_free > max_dict['SF']):
        max_dict['SF'] = swap_free
    if ('SF' not in min_dict or swap_free < min_dict['SF']):
        min_dict['SF'] = swap_free

    if ('D' not in max_dict or dirty > max_dict['D']):
        max_dict['D'] = dirty
    if ('D' not in min_dict or dirty < min_dict['D']):
        min_dict['D'] = dirty

    if ('C' not in max_dict or clean > max_dict['C']):
        max_dict['C'] = clean
    if ('C' not in min_dict or clean < min_dict['C']):
        min_dict['C'] = clean

    # MA=8395=86% MF=8407 A=98 F=198 AF=129 IF=69 D=3 C=195 SF=46834=95%

    log(
        'MA={}={}% MF={} A={} F={} AF={} IF={} D={} C={} ISF={} SF={}={}%'.format(
            round(mem_available / 1024),
            round(mem_available / mem_total * 100),
            round(mem_free / 1024),
            round(anon / 1024),
            round(total_file / 1024),
            round(active_file / 1024),
            round(inactive_file / 1024),
            round(dirty / 1024),
            round(clean / 1024),
            round(isf / 1024),
            round(swap_free / 1024),
            round(swap_free / (swap_total + 1) * 100)
        ))

    sleep(interval)












