#!/usr/bin/env python3
"""A daemon that prevents OOM in Linux systems."""

import os
from ctypes import CDLL
from time import sleep, monotonic, process_time
from operator import itemgetter
from sys import stdout, stderr, argv, exit
from re import search
from sre_constants import error as invalid_re
from signal import signal, SIGKILL, SIGTERM, SIGINT, SIGQUIT, SIGHUP






###########################################################################################################################
###########################################################################################################################
# 1 До цикла







def find_cgroup_indexes():
    """ Find cgroup-line positions in /proc/*/cgroup file.
    """
    cgroup_systemd_index = cgroup_unified_index = None

    with open('/proc/self/cgroup') as f:
        for index, line in enumerate(f):
            if ':name=systemd:' in line:
                cgroup_systemd_index = index
            if line.startswith('0::'):
                cgroup_unified_index = index

    (cgroup_systemd_mountpoint, cgroup_unified_mountpoint
     ) = find_cgroup_mountpoints()

    if (cgroup_systemd_mountpoint is None and
            cgroup_unified_mountpoint is not None):

        if os.path.exists('{}/system.slice'.format(cgroup_unified_mountpoint)):
            cgroup_systemd_index = cgroup_unified_index

    return cgroup_systemd_index, cgroup_unified_index


def find_cgroup_mountpoints():
    """
    """
    mounts = '/proc/mounts'

    cgroup_systemd_marker = ',name=systemd 0 0'
    cgroup_systemd_separator = ' cgroup rw,'
    cgroup_unified_separator = ' cgroup2 rw,'

    cgroup_unified_mountpoint = cgroup_systemd_mountpoint = None

    with open(mounts) as f:

        for line in f:

            if cgroup_systemd_marker in line:
                cgroup_systemd_mountpoint = line.partition(
                    cgroup_systemd_separator)[0].partition(' ')[2]
                continue

            if cgroup_unified_separator in line:
                cgroup_unified_mountpoint = line.partition(
                    cgroup_unified_separator)[0].partition(' ')[2]

    if not os.path.exists('{}/system.slice'.format(cgroup_systemd_mountpoint)):
        cgroup_systemd_mountpoint = None

    return cgroup_systemd_mountpoint, cgroup_unified_mountpoint


def get_pid_list():
    """
    Find pid list expect kthreads and zombies
    """
    pid_list = []
    for pid in os.listdir('/proc'):
        if os.path.exists('/proc/' + pid + '/exe'):
            pid_list.append(pid)
    return pid_list


def get_non_decimal_pids():
    """
    """
    non_decimal_list = []
    for pid in pid_list:
        if pid[0].isdecimal() is False:
            non_decimal_list.append(pid)
    return non_decimal_list


def log(*msg):
    """
    """
    print(*msg)
    if separate_log:
        logging.info(*msg)


def conf_parse_bool(param):
    """
    Get bool parameters from the config_dict.

    param: config_dicst key
    returns bool
    """
    if param in config_dict:
        param_str = config_dict[param]
        if param_str == 'True':
            return True
        elif param_str == 'False':
            return False
        else:
            errprint('Invalid value of the "{}" parameter.'.format(param))
            errprint('Valid values are True and False.')
            errprint('Exit')
            exit(1)
    else:
        errprint('All the necessary parameters must be in the config')
        errprint('There is no "{}" parameter in the config'.format(param))
        exit(1)


def calculate_percent(arg_key):
    """
    parse conf dict
    Calculate mem_min_KEY_percent.

    Try use this one)
    arg_key: str key for config_dict
    returns int mem_min_percent or NoneType if got some error
    """

    if arg_key in config_dict:
        mem_min = config_dict[arg_key]

        if mem_min.endswith('%'):
            # truncate percents, so we have a number
            mem_min_percent = mem_min[:-1].strip()
            # then 'float test'
            mem_min_percent = string_to_float_convert_test(mem_min_percent)
            if mem_min_percent is None:
                errprint('Invalid {} value, not float\nExit'.format(arg_key))
                exit(1)
            # Final validations...
            if mem_min_percent < 0 or mem_min_percent > 100:
                errprint(
                    '{}, as percents value, out of ran'
                    'ge [0; 100]\nExit'.format(arg_key))
                exit(1)

            # soft_threshold_min_mem_percent is clean and valid float percentage. Can
            # translate into Kb
            mem_min_kb = mem_min_percent / 100 * mem_total
            mem_min_mb = round(mem_min_kb / 1024)

        elif mem_min.endswith('M'):
            mem_min_mb = string_to_float_convert_test(mem_min[:-1].strip())
            if mem_min_mb is None:
                errprint('Invalid {} value, not float\nExit'.format(arg_key))
                exit(1)
            mem_min_kb = mem_min_mb * 1024
            if mem_min_kb > mem_total:
                errprint(
                    '{} value can not be greater then MemT'
                    'otal ({} MiB)\nExit'.format(
                        arg_key, round(
                            mem_total / 1024)))
                exit(1)
            mem_min_percent = mem_min_kb / mem_total * 100

        else:
            log('Invalid {} units in config.\n Exit'.format(arg_key))
            exit(1)
            mem_min_percent = None

    else:
        log('{} not in config\nExit'.format(arg_key))
        exit(1)
        mem_min_percent = None

    return mem_min_kb, mem_min_mb, mem_min_percent


def string_to_float_convert_test(string):
    """Try to interprete string values as floats."""
    try:
        return float(string)
    except ValueError:
        return None


def string_to_int_convert_test(string):
    """Try to interpret string values as integers."""
    try:
        return int(string)
    except ValueError:
        return None


def errprint(*text):
    """
    """
    print(*text, file=stderr, flush=True)
    try:
        if separate_log:
            logging.info(*msg)
    except NameError:
        pass


def get_swap_threshold_tuple(string):
    # re (Num %, True) or (Num KiB, False)
    """Returns KiB value if abs val was set in config, or tuple with %"""
    # return tuple with abs and bool: (abs %, True) or (abs MiB, False)
    if string.endswith('%'):
        valid = string_to_float_convert_test(string[:-1])
        if valid is None:
            errprint('somewhere swap unit is not float_%')
            exit(1)

        value = float(string[:-1].strip())
        if value < 0 or value > 100:
            errprint('invalid value, must be from the range[0; 100] %')
            exit(1)

        return value, True

    elif string.endswith('M'):
        valid = string_to_float_convert_test(string[:-1])
        if valid is None:
            errprint('somewhere swap unit is not float_M')
            exit(1)

        value = float(string[:-1].strip()) * 1024
        if value < 0:
            errprint('invalid unit in config (negative value)')
            exit(1)

        return value, False

    else:
        errprint(
            'Invalid config file. There are invalid units somewhere\nExit')
        exit(1)


def mlockall():
    """Lock all memory to prevent swapping nohang process."""

    MCL_CURRENT = 1
    MCL_FUTURE = 2
    MCL_ONFAULT = 4

    libc = CDLL('libc.so.6', use_errno=True)

    result = libc.mlockall(
        MCL_CURRENT | MCL_FUTURE | MCL_ONFAULT
    )
    if result != 0:
        result = libc.mlockall(
            MCL_CURRENT | MCL_FUTURE
        )
        if result != 0:
            log('WARNING: cannot lock all memory')
        else:
            pass
            # log('All memory locked with MCL_CURRENT | MCL_FUTURE')
    else:
        pass
        # log('All memory locked with MCL_CURRENT | MCL_FUTURE | MCL_ONFAULT')


def signal_handler(signum, frame):
    """
    """
    for i in sig_list:
        signal(i, signal_handler_inner)

    log('Signal handler called with the {} signal '.format(
        sig_dict[signum]))

    update_stat_dict_and_print(None)

    m1 = monotonic()
    pt1 = process_time()
    x = (pt1 - pt0) / (m1 - m0) * 100
    log('CPU usage by nohang since it started: {}%'.format(round(x, 3)))

    log('Exit')
    exit()


def signal_handler_inner(signum, frame):
    """
    """
    log('Signal handler called with the {} signal (ignored) '.format(
        sig_dict[signum]))


def valid_re(reg_exp):
    """Validate regular expression.
    """
    try:
        search(reg_exp, '')
    except invalid_re:
        log('Invalid config: invalid regexp: {}'.format(reg_exp))
        exit(1)


def check_config():
    """
    """
    log('#' * 79)

    log('\n1. Common zram settings')

    log('    zram_checking_enabled:   {}'.format(zram_checking_enabled))

    log('\n2. Common PSI settings')

    log('    psi_checking_enabled:    {}'.format(psi_checking_enabled))
    log('    psi_path:                {}'.format(psi_path))
    log('    psi_metrics:             {}'.format(psi_metrics))
    log('    psi_excess_duration:     {} sec'.format(psi_excess_duration))
    log('    psi_post_action_delay:   {} sec'.format(psi_post_action_delay))

    log('\n3. Poll rate')

    log('    fill_rate_mem:   {}'.format(fill_rate_mem))
    log('    fill_rate_swap:  {}'.format(fill_rate_swap))
    log('    fill_rate_zram:  {}'.format(fill_rate_zram))
    log('    max_sleep:       {} sec'.format(max_sleep))
    log('    min_sleep:       {} sec'.format(min_sleep))
    log('    over_sleep:      {} sec'.format(over_sleep))

    log('\n4. Warnings and notifications')

    log('    post_action_gui_notifications:  {}'.format(
        post_action_gui_notifications))

    log('    low_memory_warnings_enabled:    {}'.format(
        low_memory_warnings_enabled))
    log('    warning_exe:                    {}'.format(warning_exe))
    log('    warning_threshold_min_mem:      {} MiB, {} %'.format(round(
        warning_threshold_min_mem_mb), round(
            warning_threshold_min_mem_percent, 1)))
    log('    warning_threshold_min_swap:     {}'.format
        (warning_threshold_min_swap))
    log('    warning_threshold_max_zram:     {} MiB, {} %'.format(round(
        warning_threshold_max_zram_mb), round(
            warning_threshold_max_zram_percent, 1)))
    log('    warning_threshold_max_psi:      {}'.format(
        warning_threshold_max_psi))
    log('    min_post_warning_delay:         {} sec'.format(
        min_post_warning_delay))

    log('    env_cache_time:                 {}'.format(env_cache_time))

    log('\n5. Soft threshold')

    log('    soft_threshold_min_mem:   {} MiB, {} %'.format(
        round(soft_threshold_min_mem_mb), round(
            soft_threshold_min_mem_percent, 1)))
    log('    soft_threshold_min_swap:  {}'.format(soft_threshold_min_swap))
    log('    soft_threshold_max_zram:  {} MiB, {} %'.format(
        round(soft_threshold_max_zram_mb), round(
            soft_threshold_max_zram_percent, 1)))
    log('    soft_threshold_max_psi:   {}'.format(soft_threshold_max_psi))

    log('\n6. Hard threshold')

    log('    hard_threshold_min_mem:   {} MiB, {} %'.format(
        round(hard_threshold_min_mem_mb), round(
            hard_threshold_min_mem_percent, 1)))
    log('    hard_threshold_min_swap:  {}'.format(hard_threshold_min_swap))
    log('    hard_threshold_max_zram:  {} MiB, {} %'.format(
        round(hard_threshold_max_zram_mb), round(
            hard_threshold_max_zram_percent, 1)))
    log('    hard_threshold_max_psi:   {}'.format(hard_threshold_max_psi))

    log('\n7. Customize victim selection: adjusting badness of processes')

    log('\n7.1. Ignore positive oom_score_adj')

    log('    ignore_positive_oom_score_adj:  {}'.format(
        ignore_positive_oom_score_adj))

    log('\n7.3. ')

    log('7.3.1. Matching process names with RE patterns')
    if len(badness_adj_re_name_list) > 0:
        log('    regexp:         badness_adj:')
        for i in badness_adj_re_name_list:
            log('    {}         {}'.format(i[1], i[0]))
    else:
        log('    (not set)')

    log('7.3.2. Matching CGroup_systemd-line with RE patterns')
    if len(badness_adj_re_cgroup_systemd_list) > 0:
        log('    regexp:              badness_adj:')
        for i in badness_adj_re_cgroup_systemd_list:
            log('    {}         {}'.format(i[1], i[0]))
    else:
        log('    (not set)')

    log('7.3.3. Matching CGroup_unified-line with RE patterns')
    if len(badness_adj_re_cgroup_unified_list) > 0:
        log('    regexp:              badness_adj:')
        for i in badness_adj_re_cgroup_unified_list:
            log('    {}         {}'.format(i[1], i[0]))
    else:
        log('    (not set)')

    log('7.3.4. Matching eUIDs with RE patterns')
    if len(badness_adj_re_uid_list) > 0:
        log('    regexp:              badness_adj:')
        for i in badness_adj_re_uid_list:
            log('    {}         {}'.format(i[1], i[0]))
    else:
        log('    (not set)')

    log('7.3.5. Matching realpath with RE patterns')
    if len(badness_adj_re_realpath_list) > 0:
        log('    regexp:              badness_adj:')
        for i in badness_adj_re_realpath_list:
            log('    {}         {}'.format(i[1], i[0]))
    else:
        log('    (not set)')

    log('7.3.5.1. Matching cwd with RE patterns')
    if len(badness_adj_re_cwd_list) > 0:
        log('    regexp:              badness_adj:')
        for i in badness_adj_re_cwd_list:
            log('    {}         {}'.format(i[1], i[0]))
    else:
        log('    (not set)')

    log('7.3.6. Matching cmdlines with RE patterns')
    if len(badness_adj_re_cmdline_list) > 0:
        log('    regexp:              badness_adj:')
        for i in badness_adj_re_cmdline_list:
            log('    {}         {}'.format(i[1], i[0]))
    else:
        log('    (not set)')

    log('7.3.7. Matching environ with RE patterns')
    if len(badness_adj_re_environ_list) > 0:
        log('    regexp:              badness_adj:')
        for i in badness_adj_re_environ_list:
            log('    {}         {}'.format(i[1], i[0]))
    else:
        log('    (not set)')

    log('\n8. Customize corrective actions')

    if len(soft_actions_list) > 0:
        log('    Match by:   regexp:     command: ')
        for i in soft_actions_list:
            log('    {}         {}        {}'.format(i[0], i[1], i[2]))
    else:
        log('    (not set)')

    log('\n9. Misc')

    log('    max_soft_exit_time:         {} sec'.format(max_soft_exit_time))

    log('    min_badness:                {}'.format(min_badness))

    log('    post_soft_action_delay:     {} sec'.format(
        post_soft_action_delay))
    log('    post_zombie_delay:          {} sec'.format(post_zombie_delay))
    log('    victim_cache_time:          {} sec'.format(victim_cache_time))
    log('    exe_timeout:                {} sec'.format(exe_timeout))

    log('\n10. Verbosity')

    log('    print_config_at_startup:    {}'.format(print_config_at_startup))

    log('    print_mem_check_results:    {}'.format(print_mem_check_results))
    log('    min_mem_report_interval:    {} sec'.format(
        min_mem_report_interval))

    log('    print_proc_table:           {}'.format(print_proc_table))
    log('    extra_table_info:           {}'.format(extra_table_info))

    log('    print_victim_status:        {}'.format(print_victim_status))
    log('    print_victim_cmdline:       {}'.format(print_victim_cmdline))
    log('    max_victim_ancestry_depth:  {}'.format(max_victim_ancestry_depth))

    log('    print_statistics:           {}'.format(print_statistics))

    log('    debug_gui_notifications:    {}'.format(debug_gui_notifications))
    log('    debug_psi:                  {}'.format(debug_psi))
    log('    debug_sleep:                {}'.format(debug_sleep))
    log('    debug_threading:            {}'.format(debug_threading))
    log('    separate_log:               {}'.format(separate_log))

    log('#' * 79)

    if check_config_flag:
        log('config is OK')
        exit()


def print_version():
    """
    """
    try:
        v = rline1('/etc/nohang/version')
    except FileNotFoundError:
        v = None
    if v is None:
        print('nohang unknown version')
    else:
        print('nohang ' + v)
    exit()


def rline1(path):
    """read 1st line from path."""
    try:
        with open(path) as f:
            for line in f:
                return line.rstrip()
    except UnicodeDecodeError:
        with open(path, 'rb') as f:
            return f.read(999).decode(
                'utf-8', 'ignore').split('\n')[0]  # use partition()!


def update_stat_dict_and_print(key):
    """
    """

    if key is not None:

        if key not in stat_dict:

            stat_dict.update({key: 1})

        else:

            new_value = stat_dict[key] + 1
            stat_dict.update({key: new_value})

    if print_statistics:

        stats_msg = 'Total stat (what happened in the last {}):'.format(
            format_time(monotonic() - start_time))

        for i in stat_dict:
            stats_msg += '\n  {}: {}'.format(i, stat_dict[i])

        log(stats_msg)


def format_time(t):
    """
    """
    t = int(t)

    if t < 60:
        return '{} sec'.format(t)

    if t > 3600:
        h = t // 3600
        s0 = t - h * 3600
        m = s0 // 60
        s = s0 % 60
        return '{} h {} min {} sec'.format(h, m, s)

    m = t // 60
    s = t % 60
    return '{} min {} sec'.format(m, s)


def func_print_proc_table():
    """
    """
    print_proc_table = True
    find_victim(print_proc_table)
    exit()


###########################################################################################################################
###########################################################################################################################
# 2 В цикле


def check_mem_swap_exceeded():
    """
    Check: is mem and swap threshold exceeded?
    Return: None, (SIGTERM, meminfo), (SIGKILL, meminfo)
    """

    mem_available, swap_total, swap_free = check_mem_and_swap()

    # if hard_threshold_min_swap is set in percent
    if swap_kill_is_percent:
        hard_threshold_min_swap_kb = swap_total * \
            hard_threshold_min_swap_percent / 100.0
    else:
        hard_threshold_min_swap_kb = swap_kb_dict['hard_threshold_min_swap_kb']

    if swap_term_is_percent:
        soft_threshold_min_swap_kb = swap_total * \
            soft_threshold_min_swap_percent / 100.0
    else:
        soft_threshold_min_swap_kb = swap_kb_dict['soft_threshold_min_swap_kb']

    if swap_warn_is_percent:
        warning_threshold_min_swap_kb = swap_total * \
            warning_threshold_min_swap_percent / 100.0
    else:
        warning_threshold_min_swap_kb = swap_kb_dict[
            'warning_threshold_min_swap_kb']

    if swap_total > hard_threshold_min_swap_kb:
        swap_sigkill_pc = percent(
            hard_threshold_min_swap_kb / (swap_total + 0.1))
    else:
        swap_sigkill_pc = '-'

    if swap_total > soft_threshold_min_swap_kb:
        swap_sigterm_pc = percent(
            soft_threshold_min_swap_kb / (swap_total + 0.1))
    else:
        swap_sigterm_pc = '-'

    if (mem_available <= hard_threshold_min_mem_kb and
            swap_free <= hard_threshold_min_swap_kb):

        mem_info = 'Memory status that requires corrective actions:\n  Mem' \
            'Available [{} MiB, {} %] <= hard_threshold_min_mem [{} MiB, ' \
            '{} %]\n  SwapFree [{} MiB, {} %] <= hard_threshold_min_swap [{} MiB, {} %]'.format(

                kib_to_mib(mem_available),
                percent(mem_available / mem_total),
                kib_to_mib(hard_threshold_min_mem_kb),
                percent(hard_threshold_min_mem_kb / mem_total),
                kib_to_mib(swap_free),
                percent(swap_free / (swap_total + 0.1)),
                kib_to_mib(hard_threshold_min_swap_kb),
                swap_sigkill_pc)

        return (SIGKILL, mem_info, mem_available, hard_threshold_min_swap_kb,
                soft_threshold_min_swap_kb, swap_free, swap_total)

    if (mem_available <= soft_threshold_min_mem_kb and
            swap_free <= soft_threshold_min_swap_kb):

        mem_info = 'Memory status that requires corrective actions:\n  MemAvailable [{} MiB, {} %] <= soft_threshold_min_mem [{} MiB, {} %]\n  SwapFree [{} MiB, {} %] <= soft_threshold_min_swap [{} MiB, {} %]'.format(

            kib_to_mib(mem_available),
            percent(mem_available / mem_total),
            kib_to_mib(soft_threshold_min_mem_kb),
            round(soft_threshold_min_mem_percent, 1),
            kib_to_mib(swap_free),
            percent(swap_free / (swap_total + 0.1)),
            kib_to_mib(soft_threshold_min_swap_kb),
            swap_sigterm_pc)

        return (SIGTERM, mem_info, mem_available, hard_threshold_min_swap_kb,
                soft_threshold_min_swap_kb, swap_free, swap_total)

    if low_memory_warnings_enabled:

        if (mem_available <= warning_threshold_min_mem_kb and swap_free <=
                warning_threshold_min_swap_kb + 0.1):
            return ('WARN', None, mem_available, hard_threshold_min_swap_kb,
                    soft_threshold_min_swap_kb, swap_free, swap_total)

    return (None, None, mem_available, hard_threshold_min_swap_kb,
            soft_threshold_min_swap_kb, swap_free, swap_total)


def check_mem_and_swap():
    """find mem_available, swap_total, swap_free"""
    with open('/proc/meminfo') as f:
        for n, line in enumerate(f):
            if n == 2:
                mem_available = int(line.split(':')[1][:-4])
                continue
            if n is swap_total_index:
                swap_total = int(line.split(':')[1][:-4])
                continue
            if n is swap_free_index:
                swap_free = int(line.split(':')[1][:-4])
                break
    return mem_available, swap_total, swap_free


def kib_to_mib(num):
    """Convert KiB values to MiB values."""
    return round(num / 1024.0)


def percent(num):
    """Interprete num as percentage."""
    return round(num * 100, 1)


def check_zram_exceeded():
    """
    """
    mem_used_zram = check_zram()

    if mem_used_zram >= hard_threshold_max_zram_kb:

        mem_info = 'Memory status that requires corrective actions:\n  MemUsedZram [{} MiB, {} %] >= hard_threshold_max_zram [{} MiB, {} %]'.format(

            kib_to_mib(mem_used_zram),
            percent(mem_used_zram / mem_total),
            kib_to_mib(hard_threshold_max_zram_kb),
            percent(hard_threshold_max_zram_kb / mem_total))

        return SIGKILL, mem_info, mem_used_zram

    if mem_used_zram >= soft_threshold_max_zram_kb:

        mem_info = 'Memory status that requires corrective actions:\n  MemUsedZram [{} MiB, {} %] >= soft_threshold_max_zram [{} M, {} %]'.format(
            kib_to_mib(mem_used_zram),
            percent(mem_used_zram / mem_total),
            kib_to_mib(soft_threshold_max_zram_kb),
            percent(soft_threshold_max_zram_kb / mem_total))

        return SIGTERM, mem_info, mem_used_zram

    if low_memory_warnings_enabled:
        if mem_used_zram >= warning_threshold_max_zram_kb:
            return 'WARN', None, mem_used_zram

    return None, None, mem_used_zram


def check_zram():
    """find MemUsedZram"""

    if not os.path.exists('/sys/block/zram0'):
        return 0

    disksize_sum = 0
    mem_used_total_sum = 0

    for dev in os.listdir('/sys/block'):
        if dev.startswith('zram'):  # заменить на проверку существования зрам-специфик фала
            stat = zram_stat(dev)
            disksize_sum += int(stat[0])
            mem_used_total_sum += int(stat[1])

    # It means that when setting zram disksize = 1 GiB available memory
    # decrease by 0.0042 GiB.
    # Found experimentally, requires clarification with different kernaels and
    # architectures.
    # On small disk drives (up to gigabyte) it can be more, up to 0.0045.
    # The creator of the zram module claims that ZRAM_DISKSIZE_FACTOR should
    # be 0.001:
    # ("zram uses about 0.1% of the size of the disk"
    # - https://www.kernel.org/doc/Documentation/blockdev/zram.txt),
    # but this statement contradicts the experimental data.
    # ZRAM_DISKSIZE_FACTOR = deltaMemAvailavle / disksize
    # Found experimentally.
    ZRAM_DISKSIZE_FACTOR = 0.0042

    return (mem_used_total_sum + disksize_sum * ZRAM_DISKSIZE_FACTOR) / 1024.0


def zram_stat(zram_id):
    """
    Get zram state.

    zram_id: str zram block-device id
    returns bytes disksize, str mem_used_total
    """
    try:
        disksize = rline1('/sys/block/' + zram_id + '/disksize')
    except FileNotFoundError:
        return '0', '0'
    if disksize == ['0\n']:
        return '0', '0'
    try:
        mm_stat = rline1('/sys/block/' + zram_id + '/mm_stat').split(' ')
        mm_stat_list = []
        for i in mm_stat:
            if i != '':
                mm_stat_list.append(i)
        mem_used_total = mm_stat_list[2]
    except FileNotFoundError:
        mem_used_total = rline1('/sys/block/' + zram_id + '/mem_used_total')
    return disksize, mem_used_total  # BYTES, str


def check_psi_exceeded(
        hard_threshold_psi_exceeded_timer,
        soft_threshold_psi_exceeded_timer,
        psi_timestamp0):
    """
    """

    psi_delta0 = monotonic() - psi_timestamp0
    psi_timestamp0 = monotonic()

    psi_avg_value = find_psi_metrics_value(psi_path, psi_metrics)
    # print(psi_avg_value)

    psi_post_action_delay_timer = monotonic() - last_action_dict['t']

    if psi_post_action_delay_timer >= psi_post_action_delay:
        psi_post_action_delay_exceeded = True
    else:
        psi_post_action_delay_exceeded = False

    if psi_avg_value >= hard_threshold_max_psi:
        hard_threshold_psi_exceeded = True
        hard_threshold_psi_exceeded_timer += psi_delta0
    else:
        hard_threshold_psi_exceeded = False
        hard_threshold_psi_exceeded_timer = 0

    if debug_psi:

        log('------------------------------------------------------------------------')

        log('psi_post_action_delay_timer: {}, psi_post_action_delay_exceeded: {}'.format(
            round(psi_post_action_delay_timer, 1), psi_post_action_delay_exceeded))

        log('hard_threshold_psi_exceeded: {}, hard_threshold_psi_exceeded_timer: {}'.format(
            hard_threshold_psi_exceeded, round(hard_threshold_psi_exceeded_timer, 1)))

    if (hard_threshold_psi_exceeded_timer >= psi_excess_duration and
            psi_post_action_delay_exceeded):

        mem_info = 'PSI ({}) > hard_threshold_max_psi ({})\n' \
            'PSI exceeded psi_excess_duration (value' \
            ' = {} sec) for {} seconds'.format(
                psi_avg_value,
                hard_threshold_max_psi,
                psi_excess_duration,
                round(hard_threshold_psi_exceeded_timer, 1)
            )

        return (SIGKILL, mem_info, hard_threshold_psi_exceeded_timer,
                soft_threshold_psi_exceeded_timer, psi_timestamp0)

    if psi_avg_value >= soft_threshold_max_psi:
        soft_threshold_psi_exceeded = True
        soft_threshold_psi_exceeded_timer += psi_delta0
    else:
        soft_threshold_psi_exceeded = False
        soft_threshold_psi_exceeded_timer = 0

    if debug_psi:

        log('soft_threshold_psi_exceeded: {}, soft_threshold_psi_exceeded_timer: {}'.format(
            soft_threshold_psi_exceeded, round(soft_threshold_psi_exceeded_timer, 1)))

    if (soft_threshold_psi_exceeded_timer >= psi_excess_duration and
            psi_post_action_delay_exceeded):

        mem_info = 'PSI ({}) > soft_threshold_max_psi ({})\n' \
            'PSI exceeded psi_excess_duration (value' \
            ' = {} sec) for {} seconds'.format(
                psi_avg_value,
                soft_threshold_max_psi,
                psi_excess_duration,
                round(soft_threshold_psi_exceeded_timer, 1)
            )

        return (SIGTERM, mem_info, hard_threshold_psi_exceeded_timer,
                soft_threshold_psi_exceeded_timer, psi_timestamp0)

    if low_memory_warnings_enabled:

        if psi_avg_value >= warning_threshold_max_psi:
            return ('WARN', None, hard_threshold_psi_exceeded_timer,
                    soft_threshold_psi_exceeded_timer, psi_timestamp0)

    return (None, None, hard_threshold_psi_exceeded_timer,
            soft_threshold_psi_exceeded_timer, psi_timestamp0)


def find_psi_metrics_value(psi_path, psi_metrics):
    """
    """

    if psi_support:

        if psi_metrics == 'some_avg10':
            return float(rline1(psi_path).split(' ')[1].split('=')[1])
        if psi_metrics == 'some_avg60':
            return float(rline1(psi_path).split(' ')[2].split('=')[1])
        if psi_metrics == 'some_avg300':
            return float(rline1(psi_path).split(' ')[3].split('=')[1])

        if psi_metrics == 'full_avg10':
            with open(psi_path) as f:
                psi_list = f.readlines()
                return float(psi_list[1].split(' ')[1].split('=')[1])
        if psi_metrics == 'full_avg60':
            with open(psi_path) as f:
                psi_list = f.readlines()
                return float(psi_list[1].split(' ')[2].split('=')[1])
        if psi_metrics == 'full_avg300':
            with open(psi_path) as f:
                psi_list = f.readlines()
                return float(psi_list[1].split(' ')[3].split('=')[1])


def human(num, lenth):
    """Convert KiB values to MiB values with right alignment"""
    return str(round(num / 1024)).rjust(lenth, ' ')


def just_percent_mem(num):
    """convert num to percent and justify"""
    return str(round(num * 100, 1)).rjust(4, ' ')


def just_percent_swap(num):
    """
    """
    return str(round(num * 100, 1)).rjust(5, ' ')


def sleep_after_check_mem():
    """Specify sleep times depends on rates and avialable memory."""

    if stable_sleep:

        if debug_sleep:
            log('Sleep {} sec'.format(min_sleep))
        stdout.flush()
        sleep(min_sleep)
        return None

    if hard_threshold_min_mem_kb < soft_threshold_min_mem_kb:
        mem_point = mem_available - soft_threshold_min_mem_kb
    else:
        mem_point = mem_available - hard_threshold_min_mem_kb

    if hard_threshold_min_swap_kb < soft_threshold_min_swap_kb:
        swap_point = swap_free - soft_threshold_min_swap_kb
    else:
        swap_point = swap_free - hard_threshold_min_swap_kb

    if swap_point < 0:
        swap_point = 0

    if mem_point < 0:
        mem_point = 0

    t_mem = mem_point / fill_rate_mem
    t_swap = swap_point / fill_rate_swap

    if CHECK_ZRAM:
        t_zram = (mem_total * 0.8 - mem_used_zram) / fill_rate_zram
        if t_zram < 0:
            t_zram = 0
        t_mem_zram = t_mem + t_zram
        z = ', t_zram={}'.format(round(t_zram, 2))
    else:
        z = ''

    t_mem_swap = t_mem + t_swap

    if CHECK_ZRAM:

        if t_mem_swap <= t_mem_zram:
            t = t_mem_swap
        else:
            t = t_mem_zram
    else:
        t = t_mem_swap

    if t > max_sleep:
        t = max_sleep
    elif t < min_sleep:
        t = min_sleep
    else:
        pass

    if debug_sleep:
        log('Sleep {} sec (t_mem={}, t_swap={}{})'.format(round(t, 2), round(
            t_mem, 2), round(t_swap, 2), z))

    stdout.flush()
    sleep(t)


###########################################################################################################################
###########################################################################################################################
# 3 Работа с внешними командами: эксе, треды, уведомл


def send_notify_warn():
    """ Implement Low memory warnings
    """
    log('Warning threshold exceeded')

    if check_warning_exe:
        start_thread(exe, warning_exe)

    else:

        title = 'Low memory'

        body = 'MemAvail: {}%\nSwapFree: {}%'.format(
            round(mem_available / mem_total * 100),
            round(swap_free / (swap_total + 0.1) * 100)
        )

        start_thread(send_notification, title, body)


def start_thread(func, *a, **k):
    """ run function in a new thread
    """

    th = threading.Thread(target=func, args=a, kwargs=k, daemon=True)
    th_name = th.getName()

    if debug_threading:

        log('Starting {} from {}'.format(
            th_name, threading.current_thread().getName()
        ))

    try:

        t1 = monotonic()
        th.start()
        t2 = monotonic()

        if debug_threading:
            log('{} has started in {} ms, {} threads are '
                'currently alive'.format(th_name, round((
                    t2 - t1) * 1000, 1), threading.active_count()))

    except RuntimeError:

        log('RuntimeError: cannot start {}'.format(th_name))

        return 1


def exe(cmd):
    """ execute cmd in subprocess.Popen()
    """
    cmd_list = shlex.split(cmd)

    cmd_num_dict['cmd_num'] += 1
    cmd_num = cmd_num_dict['cmd_num']

    log('Execute the command ({}) in {}: {}'.format(
        cmd_num,
        threading.current_thread().getName(),
        cmd_list))
    t3 = monotonic()
    with Popen(cmd_list) as proc:
        try:
            proc.wait(timeout=exe_timeout)
            exit_status = proc.poll()
            t4 = monotonic()
            log('Command ({}) execution completed in {} sec; exit status'
                ': {}'.format(cmd_num, round(t4 - t3, 3), exit_status))
        except TimeoutExpired:
            proc.kill()
            t4 = monotonic()
            log('TimeoutExpired for the command ({}) in {} sec'.format(
                cmd_num, round(t4 - t3, 3)))


def send_notification(title, body):
    """
    """
    if self_uid != 0:
        cmd = ['notify-send', '--icon=dialog-warning', title, body]
        username = '(UID={})'.format(self_uid)
        pop(cmd, username)
        return None

    t1 = monotonic()

    if envd['t'] is None:

        list_with_envs = root_notify_env()
        envd['list_with_envs'] = list_with_envs
        envd['t'] = monotonic()
        cached_env = ''

    elif monotonic() - envd['t'] > env_cache_time:

        list_with_envs = root_notify_env()
        envd['list_with_envs'] = list_with_envs
        envd['t'] = monotonic()
        cached_env = ''

    else:

        list_with_envs = envd['list_with_envs']
        cached_env = ' (cached)'

    t2 = monotonic()

    if debug_gui_notifications:

        log('Found env in {} ms{}'.format(round((t2 - t1) * 1000), cached_env))
        log('Title:     {}'.format([title]))
        log('Body:      {}'.format([body]))
        log('Env list:  {}'.format(list_with_envs))

    list_len = len(list_with_envs)

    # if somebody logged in with GUI
    if list_len > 0:

        # iterating over logged-in users
        for i in list_with_envs:
            username, display_env, dbus_env = i[0], i[1], i[2]
            display_tuple = display_env.partition('=')
            dbus_tuple = dbus_env.partition('=')
            display_value = display_tuple[2]
            dbus_value = dbus_tuple[2]

            cmd = [
                'sudo', '-u', username,
                'env',
                'DISPLAY=' + display_value,
                'DBUS_SESSION_BUS_ADDRESS=' + dbus_value,
                'notify-send',
                '--icon=dialog-warning',
                title,
                body
            ]

            start_thread(pop, cmd, username)

    else:
        if debug_gui_notifications:
            log('Nobody logged-in with GUI. Nothing to do.')


def pop(cmd, username):
    """ run cmd in subprocess.Popen() - Уведомл обычного юзера
    """

    cmd_num_dict['cmd_num'] += 1
    cmd_num = cmd_num_dict['cmd_num']

    log('Execute the Command-{} {} in {}'.format(
        cmd_num,
        cmd,
        threading.current_thread().getName()
    ))

    if swap_total == 0:
        wait_time = 2
    else:
        wait_time = 20

    t3 = monotonic()

    with Popen(cmd) as proc:
        try:
            proc.wait(timeout=wait_time)
            err = proc.poll()
            t4 = monotonic()

            if debug_gui_notifications:
                log('Popen time: {} sec; exit status: {}; cmd: {}'.format(
                    round(t4 - t3, 3), err, cmd))

        except TimeoutExpired:
            proc.kill()

            if debug_gui_notifications:
                log('TimeoutExpired: notify user: {}'.format(username))


def root_notify_env():
    """return set(user, display, dbus)"""



    m1 = monotonic()


    unsorted_envs_list = []
    nologin_loginuid = pid_to_loginuid('1')
    # iterates over processes, find processes with suitable env
    for pid in alive_pid_list():
        loginuid = pid_to_loginuid(pid)
        if loginuid != nologin_loginuid:
            one_env = re_pid_environ(pid)
            unsorted_envs_list.append(one_env)

    env = set(unsorted_envs_list)
    env.discard(None)

    # deduplicate dbus
    new_env = []
    end = []
    for i in env:
        key = i[0] + i[1]
        if key not in end:
            end.append(key)
            new_env.append(i)
        else:
            continue


    m2 = monotonic()
    print(m2 - m1)



    return new_env


def re_pid_environ(pid):
    """
    read environ of 1 process
    returns tuple with USER, DBUS, DISPLAY like follow:
    ('user', 'DISPLAY=:0',
     'DBUS_SESSION_BUS_ADDRESS=unix:path=/run/user/1000/bus')
    returns None if these vars is not in /proc/[pid]/environ
    """
    try:
        with open('/proc/' + pid + '/environ') as f:
            env = f.read()
    except FileNotFoundError:
        log('notify helper: FileNotFoundError')
        return None
    except ProcessLookupError:
        log('notify helper: ProcessLookupError')
        return None

    if display_env in env and dbus_env in env and user_env in env:

        env_list = env.split('\x00')

        # iterating over a list of process environment variables
        for i in env_list:

            # exclude Display Manager's user
            if i.startswith('HOME=/var'):
                return None

            if i.startswith(user_env):
                user = i
                if user == 'USER=root':
                    return None
                continue

            if i.startswith(display_env):
                display = i[:10]
                continue

            if i.startswith(dbus_env):
                dbus = i
                continue

        try:
            return user.partition('USER=')[2], display, dbus
        except UnboundLocalError:
            log('notify helper: UnboundLocalError')
            return None


def send_notify(threshold, name, pid):
    """
    Notificate about OOM Preventing.

    threshold: key for notify_sig_dict
    name: str process name
    pid: str process pid
    """

    title = 'System hang prevention'

    if hide_corrective_action_type:
        body = 'Corrective action applied'
    else:
        body = '<b>{}</b> [{}] <b>{}</b>'.format(
            notify_sig_dict[threshold],
            pid,
            name.replace(
                # symbol '&' can break notifications in some themes,
                # therefore it is replaced by '*'
                '&', '*'
            ))

    start_thread(send_notification, title, body)


def send_notify_etc(pid, name, command):
    """
    Notificate about OOM Preventing.

    command: str command that will be executed
    name: str process name
    pid: str process pid
    """
    title = 'System hang prevention'
    if hide_corrective_action_type:
        body = 'Corrective action applied'
    else:
        body = '<b>Victim is</b> [{}] <b>{}</b>\nExecute the command:\n<b>' \
               '{}</b>'.format(pid, name.replace(
                   '&', '*'), command.replace('&', '*'))

    start_thread(send_notification, title, body)


###########################################################################################################################
###########################################################################################################################
# 4 Имплемент


def alive_pid_list():
    """
    """
    pid_list = get_pid_list()

    pid_list.remove(self_pid)
    if '1' in pid_list:
        pid_list.remove('1')

    for i in non_decimal_list:
        if i in pid_list:
            pid_list.remove(i)
    return pid_list


def find_shells_set():
    """
    """
    shells_set = set()
    with open('/etc/shells') as f:
        for line in f:
            if line.startswith('/'):
                shells_set.add(os.path.realpath(line.strip()))
    return shells_set


def sid_to_sid_list(sid):
    """
    """
    sid_list = []
    alive_list = alive_pid_list()

    for pid in alive_list:
        s = pid_to_sid(pid)
        if s == sid:
            sid_list.append(pid)

    return sid_list


def cgroup_unified_to_proc_list(cgroup):
    """
    """
    _, cg_u_mp = find_cgroup_mountpoints()
    if cg_u_mp is None:
        return []
    procs_path = '{}{}/cgroup.procs'.format(cg_u_mp, cgroup)
    proc_list = []
    try:
        with open(procs_path) as f:
            for pid in f:
                proc_list.append(pid[:-1])
        return proc_list
    except FileNotFoundError:
        return []
    except ProcessLookupError:
        return []


def cgroup_systemd_to_proc_list(cgroup):
    """
    """
    cg_s_mp, cg_u_mp = find_cgroup_mountpoints()
    if cg_s_mp is None:
        if cg_u_mp is not None:
            if os.path.exists('{}/system.slice'.format(cg_u_mp)):
                cg_s_mp = cg_u_mp
            else:
                return []
        else:
            return []
    procs_path = '{}{}/cgroup.procs'.format(cg_s_mp, cgroup)
    proc_list = []
    try:
        with open(procs_path) as f:
            for pid in f:
                proc_list.append(pid[:-1])
        return proc_list
    except FileNotFoundError:
        return []
    except ProcessLookupError:
        return []


def find_victim(_print_proc_table):
    """
    Find the process with highest badness and its badness adjustment
    Return pid and badness
    """

    ft1 = monotonic()

    pid_list = alive_pid_list()

    pid_badness_list = []

    if _print_proc_table:

        if extra_table_info == 'None':
            extra_table_title = ''

        elif extra_table_info == 'cgroup_systemd':
            extra_table_title = 'CGroup_systemd'

        elif extra_table_info == 'cgroup_unified':
            extra_table_title = 'CGroup_unified'

        elif extra_table_info == 'cmdline':
            extra_table_title = 'cmdline'

        elif extra_table_info == 'environ':
            extra_table_title = 'environ'

        elif extra_table_info == 'realpath':
            extra_table_title = 'realpath'

        elif extra_table_info == 'cwd':
            extra_table_title = 'cwd'

        else:
            extra_table_title = ''

        hr = '#' * 107

        log(hr)
        log('#    PID     PPID  badness  oom_score  oom_score_adj        e'
            'UID  S  VmSize  VmRSS  VmSwap  Name             {}'.format(
                extra_table_title))
        log('#-------  -------  -------  ---------  -------------  -------'
            '---  -  ------  -----  ------  ---------------')

    for pid in pid_list:

        badness = pid_to_badness(pid)[0]

        if badness is None:
            continue

        if _print_proc_table:

            try:
                oom_score = rline1('/proc/' + pid + '/oom_score')
                oom_score_adj = rline1('/proc/' + pid + '/oom_score_adj')
            except FileNotFoundError:
                continue
            except ProcessLookupError:
                continue

            if pid_to_status(pid) is None:
                continue
            else:
                (name, state, ppid, uid, vm_size, vm_rss,
                 vm_swap) = pid_to_status(pid)

            if extra_table_info == 'None':
                extra_table_line = ''

            elif extra_table_info == 'cgroup_systemd':
                extra_table_line = pid_to_cgroup_systemd(pid)

            elif extra_table_info == 'cgroup_unified':
                extra_table_line = pid_to_cgroup_unified(pid)

            elif extra_table_info == 'cmdline':
                extra_table_line = pid_to_cmdline(pid)

            elif extra_table_info == 'environ':
                extra_table_line = pid_to_environ(pid)

            elif extra_table_info == 'realpath':
                extra_table_line = pid_to_realpath(pid)

            elif extra_table_info == 'cwd':
                extra_table_line = pid_to_cwd(pid)

            else:
                extra_table_line = ''

            sid = pid_to_sid(pid)
            nn = pid_to_name(sid)
            lu = pid_to_loginuid(pid)
            an = pid_to_ancestry(pid, max_victim_ancestry_depth=9)
            extra_table_line = 'SID: {} ({}) | LUID: {} | {}'.format(sid, nn, lu, an)

            log('#{}  {}  {}  {}  {}  {}  {}  {}  {}  {}  {}  {}'.format(
                pid.rjust(7),
                ppid.rjust(7),
                str(badness).rjust(7),
                oom_score.rjust(9),
                oom_score_adj.rjust(13),
                uid.rjust(10),
                state,
                str(vm_size).rjust(6),
                str(vm_rss).rjust(5),
                str(vm_swap).rjust(6),
                name.ljust(15),
                extra_table_line
            )
            )

        pid_badness_list.append((pid, badness))

    real_proc_num = len(pid_badness_list)

    # Make list of (pid, badness) tuples, sorted by 'badness' values
    # print(pid_badness_list)
    pid_tuple_list = sorted(
        pid_badness_list,
        key=itemgetter(1),
        reverse=True
    )[0]

    pid = pid_tuple_list[0]
    victim_id = get_victim_id(pid)

    # Get maximum 'badness' value
    victim_badness = pid_tuple_list[1]
    victim_name = pid_to_name(pid)

    if _print_proc_table:
        log(hr)

    log('Found {} living tasks in userspace (except init and nohang)'.format(
        real_proc_num))

    log(
        'Process with highest badness (found in {} ms):\n  PID: {}, Na'
        'me: {}, badness: {}'.format(
            round((monotonic() - ft1) * 1000),
            pid,
            victim_name,
            victim_badness
        )
    )

    return pid, victim_badness, victim_name, victim_id
































def real_implement_corrective_action(
        victim_pid, threshold, time0, vwd, victim_id, victim_name):
    """
    """

    cgroup_unified = pid_to_cgroup_unified(victim_pid)
    cgroup_systemd = pid_to_cgroup_systemd(victim_pid)
    victim_autogroup = pid_to_autogroup(victim_pid)
    victim_sid = pid_to_sid(victim_pid)
    victim_sid_name = pid_to_name(victim_sid)
    victim_sid_exe_realpath = os.path.realpath('/proc/{}/exe'.format(victim_sid))


    print(victim_sid_name, victim_sid_exe_realpath)


    log('\nSID: {} \nautogroup: {} \ncgroup_unified: {} \ncgroup_systemd: {}\n'.format(
        victim_sid,
        victim_autogroup,
        cgroup_unified,
        cgroup_systemd
        ))


    """

    1 Знаем жертву и ее свойства. Можем ее убить. - первичный имплемент сразу
    2 kill_shell_sessions_group
    3 kill_session_regex_sid_name_list
    4 kill_cgroup_unified_enabled
    5 custom_action_re_cgroup_systemd
    6 отслеживание
    7 уведомление





    """






    ttt0 = monotonic()





    killed_set = set()

    log('Implement a corrective action:')

    #################################################################
    # сигнал жертве

    try:
        os.kill(int(victim_pid), threshold)
        killed_set.add(victim_pid)
        log('  Killing process {} ({})'.format(victim_pid, victim_name))

        response_time = monotonic() - time0

        send_result = 'total response time: {} ms'.format(
            round(response_time * 1000))

        preventing_oom_message = 'Implement a corrective action:' \
            '\n  Send {} to the victim; {}'.format(
                sig_dict[threshold], send_result)

        # success = True

        if threshold is SIGKILL:
            vwd = True

    except FileNotFoundError:
        vwd = True
        # success = False
        # response_time = monotonic() - time0
        # send_result = 'no such process; response time: {} ms'.format(round(response_time * 1000))
        key = '  The victim died in the search process: ' \
            'FileNotFoundError'
    except ProcessLookupError:
        vwd = True
        # success = False
        # response_time = monotonic() - time0
        # send_result = 'no such process; response time: {} ms'.format(round(response_time * 1000))
        key = '  The victim died in the search process: ' \
            'ProcessLookupError'

    ########################################################################









    autogroup_was_killed = False



    if kill_shell_sessions_group:

        if victim_sid_exe_realpath in find_shells_set():
            print('Killing autogroup {}'.format(victim_autogroup))



            for pid in alive_pid_list():
                #print(pid)
                if is_unkillable(pid):
                    #print('U!')
                    continue
                au = pid_to_autogroup(pid)
                #print(au)
                if au == victim_autogroup and pid not in killed_set:
                    try:
                        os.kill(int(pid), SIGKILL)
                        killed_set.add(pid)
                        log('Killing process {} ({})'.format(
                            pid, pid_to_name(pid)))
                    except FileNotFoundError:
                        pass
                    except ProcessLookupError:
                        pass
            autogroup_was_killed = True

    #print('Killed tasks:', killed_set)



    #################################################################
    # убиваем сессию










    #print(kill_session_regex_sid_name_list)






    # Можно ли выделить в фцию? Знаем пид жертвы - убиваем ее сессию.
    if kill_session_enabled and not autogroup_was_killed:

        kill_session = False

        for sid_name_re in kill_session_regex_sid_name_list:
            if search(sid_name_re, victim_sid_name) is not None:
                kill_session = True
                vwd = True
                killed_session_counter = 1
                log("  Regular expression '{}' matches with session leader name '{}'".format(
                    sid_name_re, victim_sid_name))
                break

        uu1 = monotonic()

        if kill_session:

            log("  Killing victim's session (SID: {}, session leader: {}, autogroup: {})".format(
                victim_sid, victim_sid_name, victim_autogroup))

            if victim_sid != victim_pid:

                try:
                    if victim_sid not in killed_set:
                        os.kill(int(victim_sid), SIGKILL)
                        killed_set.add(victim_sid)
                        killed_session_counter += 1
                    log('  Killing process {} ({})'.format(victim_sid, victim_sid_name))
                except FileNotFoundError:
                    log('  FileNotFoundError')
                except ProcessLookupError:
                    log('  ProcessLookupError')

            pid_list = alive_pid_list()
            # pid_set = set(pid_list)

            for pid in pid_list:

                if pid in killed_set:
                    continue

                au = pid_to_autogroup(pid)

                if au == victim_autogroup:

                    try:
                        if pid not in killed_set:
                            os.kill(int(pid), SIGKILL)
                            killed_set.add(pid)
                            killed_session_counter += 1
                        log('  Killing process {} ({})'.format(pid, pid_to_name(pid)))
                    except FileNotFoundError:
                        log('  FileNotFoundError')
                    except ProcessLookupError:
                        log('  ProcessLookupError')
            autogroup_was_killed = True

        if kill_session:
            print("  {} processes were killed in this session".format(
                killed_session_counter))

        uu2 = monotonic()
        print(uu2 - uu1)



    print('Killed tasks:', killed_set)











    #################################################################

    """
    if kill_cgroup_unified_enabled:
        pass
    """

    #################################################################

    if custom_action_re_cgroup_systemd:
        print('GROUP:SYSTEMD')
        kill_group_systemd = False
        for rega, kill_group, _ in custom_action_re_cgroup_systemd_list:
            print(rega, kill_group)
            print(rega, cgroup_systemd)
            if search(rega, cgroup_systemd) is not None and kill_group:
                kill_group_systemd = True
                break

        print('Будет убита?', kill_group_systemd)

        if kill_group_systemd:
            log("  Killing victim's systemd cgroup '{}'".format(
                cgroup_systemd))
            cg_proc_list = cgroup_systemd_to_proc_list(cgroup_systemd)

            killed_cg_counter = 1
            for pid in cg_proc_list:
                if pid == victim_pid:
                    continue

                try:
                    os.kill(int(pid), SIGKILL)
                    killed_cg_counter += 1
                    log('  Killing process {} ({})'.format(
                        pid, pid_to_name(pid)))

                except FileNotFoundError:
                    log('  FileNotFoundError')
                except ProcessLookupError:
                    log('  FileNotFoundError')

            print(killed_cg_counter)

        #cg_proc_list = cgroup_systemd_to_proc_list(cgroup_systemd)
        # print(cg_proc_list)

        # sleep(5)

        #cg_proc_list = cgroup_systemd_to_proc_list(cgroup_systemd)
        # print(cg_proc_list)

    #################################################################
    # отслеживание жертвы

    if not vwd:
        if victim_id not in v_dict:
            v_dict[victim_id] = dict()
        v_dict[victim_id]['time'] = monotonic()
        v_dict[victim_id]['name'] = victim_name
    else:
        pass

    last_action_dict['t'] = kill_timestamp = monotonic()

    # print(v_dict)

    # response_time = monotonic() - time0

    # log('success:         ' + str(success))
    # log('victim will die: ' + str(vwd))
    # log('response_time:   ' + str(response_time) + ' sec')

    # НАЧАЛО ОТСЛЕЖИВАНИЯ СОСТОЯНИЯ ЖЕРТВЫ. Можно вынести в отд фц. Приним
    # айди, логирует, возвращает что-то.

    # Далее поработать со словарями. Жертва тут умерла - сброс таймера. Все
    # старые жертвы умерли до 3х секунд с следующих циклах - сброс таймера.
    # После этого все должно быть супер охуенно.

    # ??? - Это было для пси. Перепротестировать. Не сломано ли пси теперь?
    kill_timestamp = ttt0

    while True:
        sleep(0.01)
        iva = is_victim_alive(victim_id)
        d = monotonic() - kill_timestamp
        if iva == 'X':
            if victim_id in v_dict:
                v_dict.pop(victim_id)
            a = d
            break
        elif iva == 'E':
            b = d
            if not vwd and d > sensitivity_test_time:
                break
        elif iva == 'R':
            c = d
            pass
        else:
            if victim_id in v_dict:
                v_dict.pop(victim_id)
            e = d
            sleep(post_zombie_delay)
            break

    ttt5 = monotonic()

    try:
        print(a)
    except Exception:
        pass
        #print('a ---')

    try:
        print(b)
    except Exception:
        pass
        #print('b ---')

    try:
        print(c)
    except Exception:
        pass
        #print('c ---')

    try:
        print(e)
    except Exception:
        pass
        #print('e ---')

    print('ttt5', ttt5 - kill_timestamp)

    mem_available, swap_total, swap_free = check_mem_and_swap()
    ma_mib = int(mem_available) / 1024.0
    sf_mib = int(swap_free) / 1024.0
    log('Memory status after implementing a corrective act'
        'ion:\n  MemAvailable'
        ': {} MiB, SwapFree: {} MiB'.format(
            round(ma_mib, 1), round(sf_mib, 1)))

    soft_match = False  # исправить костыль
    if soft_match is False:
        key = '  Send {} to {}'.format(sig_dict[threshold], victim_name)
        update_stat_dict_and_print(key)
    else:
        key = "  Run the command '{}'".format(command)
        update_stat_dict_and_print(key)

    #################################################################
    # тут запуск команды

    if post_action_gui_notifications:
        if soft_match:
            send_notify_etc(pid, victim_name, cmd)
        else:
            if autogroup_was_killed:
                send_notify(SIGKILL, victim_name + '\n and its autogroup', victim_pid)
            else:
                send_notify(threshold, victim_name, victim_pid)












































def implement_corrective_action(
        threshold,
        mem_info_list,
        hard_threshold_psi_exceeded_timer,
        soft_threshold_psi_exceeded_timer,
        psi_timestamp0,
        psi_threshold,
        zram_threshold,
        zram_info,
        psi_info):

    log('>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>')

    time0 = monotonic()
    debug_corrective_action = True

    for i in mem_info_list:
        log(i)  # печат превышенные пороги

    # 3
    # 1. Очистка словаря от мертвых. Итерация по словарю, отслеживание умирающих.
    # 2. Итерация по оставшемуся словарю. Поиск дельт. Если хоть у одного
    # дельта НЕ истекла - ЖДЕМ, выход из фции.

    print('Словарь живых на входе', v_dict)

    deadlist = []    # ?  nu -> deadlist     # сожержит victim_id

    for victim_id in v_dict:      # ищем недобитых
        iva = is_victim_alive(victim_id)
        print(iva, victim_id)
        if iva == 'X' or iva == 'Z':
            deadlist.append(victim_id)  # наполняем спосик умерших
        """
            continue
        if iva == 'E':
            continue
        if iva == 'R':
            pass # быстро отследить умирающего
        """

    for i in deadlist:
        if debug_corrective_action:
            log('Remove {} from v_dict'.format(i))
        # итерируемся по списку мёртвых и удаляем мертвых из словаря живых
        # жертв
        v_dict.pop(i)

    print('Словарь жив жертв после удал мертвых', v_dict)

    use_cached_victim = False  # Бить ли закэшированную жертву
    cached_victims_list = []
    # cached_victims_list.append(('foo', 0.01))
    # cached_victims_list.append(('boo', 1111.01))
    # 2
    # print(v_dict)

    for victim_id in v_dict:            # итерируемся по живым недобитым жертвам
        tx = v_dict[victim_id]['time']  # время прошлого действия
        ddt = monotonic() - tx          # Сколько времени прошло с прошлого действия
        if ddt < victim_cache_time:     # Если время кэшир жертвы не истекло

            if debug_corrective_action:
                log('victim_cache_time is not exceeded for {} (тут подробнее расшифровать айди) ({} < {}), будем добивать старую живую кэшированную недобитую жертву'.format(
                    victim_id, round(ddt, 3), victim_cache_time))
            use_cached_victim = True  # действительно использ кэширован жертву
            # наполн список недобитых. Там же и время, чтоб взять наиболее
            # свежую жертву
            cached_victims_list.append((victim_id, ddt))
            break

    if use_cached_victim:
        print(cached_victims_list)
        sorted_cached_victims_list = sorted(
            cached_victims_list,
            key=itemgetter(1),
            reverse=False)  # находим последнюю жертву
        # нашли виктим айди
        cached_victim_id = sorted_cached_victims_list[0][0]

    if use_cached_victim:
        victim_id = cached_victim_id
        pid = victim_id.partition('_pid')[2]
        victim_badness = pid_to_badness(pid)[0]
        name = v_dict[victim_id]['name']
        log('New victim is cached victim {} ({})'.format(pid, name))

    else:
        pid, victim_badness, name, victim_id = find_victim(
            print_proc_table)  # ищем новую жертву если в кэше нет

    # 3
    # RECHECK уровней памяти, уточнение порога после поиска жертвы

    log('Recheck memory levels...')

    (masf_threshold, masf_info, mem_available, hard_threshold_min_swap_kb,
     soft_threshold_min_swap_kb, swap_free, swap_total
     ) = check_mem_swap_exceeded()

    if CHECK_ZRAM:
        zram_threshold, zram_info, mem_used_zram = check_zram_exceeded()

    if CHECK_PSI:
        (psi_threshold,
         psi_info,
         hard_threshold_psi_exceeded_timer,
         soft_threshold_psi_exceeded_timer,
         psi_timestamp0) = check_psi_exceeded(hard_threshold_psi_exceeded_timer,
                                              soft_threshold_psi_exceeded_timer,
                                              psi_timestamp0)

    if (masf_threshold is SIGKILL or zram_threshold is SIGKILL or
            psi_threshold is SIGKILL):

        new_threshold = SIGKILL
        mem_info_list = []

        if masf_threshold is SIGKILL or masf_threshold is SIGTERM:
            mem_info_list.append(masf_info)

        if zram_threshold is SIGKILL or zram_threshold is SIGTERM:
            mem_info_list.append(zram_info)

        if psi_threshold is SIGKILL or psi_threshold is SIGTERM:
            mem_info_list.append(psi_info)

    elif (masf_threshold is SIGTERM or zram_threshold is SIGTERM or
          psi_threshold is SIGTERM):

        new_threshold = SIGTERM
        mem_info_list = []

        if masf_threshold is SIGKILL or masf_threshold is SIGTERM:
            mem_info_list.append(masf_info)

        if zram_threshold is SIGKILL or zram_threshold is SIGTERM:
            mem_info_list.append(zram_info)

        if psi_threshold is SIGKILL or psi_threshold is SIGTERM:
            mem_info_list.append(psi_info)

    else:
        log('Thresholds is not exceeded now')
        return None

    for i in mem_info_list:
        log(i)

    if new_threshold is None or new_threshold == 'WARN':
        log('Thresholds is not exceeded now')
        return None

    threshold = new_threshold

    # 3
    # CORRECTION

    vwd = None  # Victim Will Die

    if victim_badness >= min_badness:

        if threshold is SIGTERM:
            if victim_id in v_dict:
                dt = monotonic() - v_dict[victim_id]['time']
                if dt > max_soft_exit_time:
                    log('max_soft_exit_time is exceeded: the '
                        'victim will get SIGKILL')
                    threshold = SIGKILL
                else:
                    log('max_soft_exit_time is not exceeded ('
                        '{} < {}) for the victim'.format(round(
                            dt, 1), max_soft_exit_time))

                    if debug_sleep:
                        log('Sleep {} sec (over_sleep)'.format(over_sleep))
                    sleep(over_sleep)

                    log('<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<')

                    return None

        if print_victim_status:
            # victim badness ищи снова, не полагайся на старое
            victim_info = find_victim_info(pid, victim_badness, name)
            log(victim_info)

        #log('Try to implement a corrective action...')

        # дальше действие

        real_implement_corrective_action(
            pid, threshold, time0, vwd, victim_id, name)

    else:

        response_time = monotonic() - time0
        victim_badness_is_too_small = 'victim badness ({}) < min_b' \
            'adness ({}); nothing to do; response time: {} ms'.format(
                victim_badness,
                min_badness,
                round(response_time * 1000))

        log(victim_badness_is_too_small)

        # update stat_dict
        key = 'victim badness < min_badness'
        update_stat_dict_and_print(key)

    if vwd is None:

        if debug_sleep:
            log('Sleep {} sec (over_sleep)'.format(over_sleep))
        sleep(over_sleep)

    print(v_dict)

    log('<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<')


###########################################################################################################################
###########################################################################################################################
# 5 Состояние процесса


def pid_to_autogroup(pid):
    """
    """
    try:
        return rline1('/proc/{}/autogroup'.format(pid)).partition(
            '/autogroup-')[2].partition(' nice ')[0]
    except IndexError:
        return None
    except FileNotFoundError:
        return None
    except ProcessLookupError:
        return None


def pid_to_loginuid(pid):
    """
    """
    try:
        return rline1('/proc/{}/loginuid'.format(pid))
    except IndexError:
        return None
    except FileNotFoundError:
        return None
    except ProcessLookupError:
        return None


def pid_to_cgroup_systemd(pid):
    """
    """
    cgroup_systemd = ''
    try:
        with open('/proc/' + pid + '/cgroup') as f:
            for index, line in enumerate(f):
                if index == cgroup_systemd_index:
                    cgroup_systemd = '/' + line.partition('/')[2][:-1]
        return cgroup_systemd
    except FileNotFoundError:
        return ''
    except ProcessLookupError:
        return ''


def pid_to_cgroup_unified(pid):
    """
    """
    cgroup_unified = ''
    try:
        with open('/proc/' + pid + '/cgroup') as f:
            for index, line in enumerate(f):
                if index == cgroup_unified_index:
                    cgroup_unified = line[3:-1]
        return cgroup_unified
    except FileNotFoundError:
        return ''
    except ProcessLookupError:
        return ''


def uptime():
    """
    """
    return float(rline1('/proc/uptime').split(' ')[0])


def pid_to_starttime(pid):
    """
    """
    try:
        starttime = rline1('/proc/' + pid + '/stat').rpartition(')')[
            2].split(' ')[20]
    except FileNotFoundError:
        return ''
    except ProcessLookupError:
        return ''
    except UnicodeDecodeError:
        with open('/proc/' + pid + '/stat', 'rb') as f:
            starttime = f.read().decode('utf-8', 'ignore').rpartition(
                ')')[2].split(' ')[20]

    return float(starttime) / SC_CLK_TCK


def pid_to_sid(pid):
    """
    """
    try:
        sid = rline1('/proc/' + pid + '/stat').rpartition(')')[
            2].split(' ')[4]

    except UnicodeDecodeError:
        with open('/proc/' + pid + '/stat', 'rb') as f:
            sid = f.read().decode('utf-8', 'ignore').rpartition(
                ')')[2].split(' ')[4]
    except FileNotFoundError:
        return ''
    except ProcessLookupError:
        return ''

    return sid


def pid_to_state(pid):
    """
    """
    try:
        with open('/proc/' + pid + '/stat', 'rb') as f:
            return f.read(40).decode('utf-8', 'ignore').rpartition(')')[2][1]
    except FileNotFoundError:
        return ''
    except ProcessLookupError:
        return ''
    except IndexError:
        with open('/proc/' + pid + '/stat', 'rb') as f:
            return f.read().decode('utf-8', 'ignore').rpartition(')')[2][1]


def pid_to_name(pid):
    """
    """
    try:
        with open('/proc/' + pid + '/comm', 'rb') as f:
            return f.read().decode('utf-8', 'ignore')[:-1]
    except FileNotFoundError:
        return ''
    except ProcessLookupError:
        return ''


def pid_to_ppid(pid):
    """ Получать из stat!
    """
    try:
        with open('/proc/' + pid + '/status') as f:
            for n, line in enumerate(f):
                if n is ppid_index:
                    return line.split('\t')[1].strip()
    except FileNotFoundError:
        return ''
    except ProcessLookupError:
        return ''
    except UnicodeDecodeError:
        with open('/proc/' + pid + '/status', 'rb') as f:
            f_list = f.read().decode('utf-8', 'ignore').split('\n')
            for i in range(len(f_list)):
                if i is ppid_index:
                    return f_list[i].split('\t')[1]


def pid_to_ancestry(pid, max_victim_ancestry_depth=1):
    """
    """
    if max_victim_ancestry_depth == 1:
        ppid = pid_to_ppid(pid)
        pname = pid_to_name(ppid)
        return '  PPID:      {} ({})'.format(ppid, pname)
    if max_victim_ancestry_depth == 0:
        return ''
    anc_list = []
    for i in range(max_victim_ancestry_depth):
        ppid = pid_to_ppid(pid)
        pname = pid_to_name(ppid)
        anc_list.append((ppid, pname))
        if ppid == '1':
            break
        pid = ppid
    a = ''
    for i in anc_list:
        a = a + ' <= PID {} ({})'.format(i[0], i[1])
    return '  Ancestry:  ' + a[4:]


def pid_to_cmdline(pid):
    """
    Get process cmdline by pid.

    pid: str pid of required process
    returns string cmdline
    """
    try:
        with open('/proc/' + pid + '/cmdline') as f:
            return f.read().replace('\x00', ' ').rstrip()
    except FileNotFoundError:
        return ''
    except ProcessLookupError:
        return ''


def pid_to_environ(pid):
    """
    Get process environ by pid.

    pid: str pid of required process
    returns string environ
    """
    try:
        with open('/proc/' + pid + '/environ') as f:
            return f.read().replace('\x00', ' ').rstrip()
    except FileNotFoundError:
        return ''
    except ProcessLookupError:
        return ''


def pid_to_realpath(pid):
    """
    """
    try:
        return os.path.realpath('/proc/' + pid + '/exe')
    except FileNotFoundError:
        return ''
    except ProcessLookupError:
        return ''


def pid_to_cwd(pid):
    """
    """
    try:
        return os.path.realpath('/proc/' + pid + '/cwd')
    except FileNotFoundError:
        return ''
    except ProcessLookupError:
        return ''


def pid_to_uid(pid):
    """return euid"""
    try:
        with open('/proc/' + pid + '/status') as f:
            for n, line in enumerate(f):
                if n is uid_index:
                    return line.split('\t')[2]
    except UnicodeDecodeError:
        with open('/proc/' + pid + '/status', 'rb') as f:
            f_list = f.read().decode('utf-8', 'ignore').split('\n')
            return f_list[uid_index].split('\t')[2]
    except FileNotFoundError:
        return ''
    except ProcessLookupError:
        return ''


def pid_to_status(pid):
    """
    """

    try:

        with open('/proc/' + pid + '/status') as f:

            for n, line in enumerate(f):

                if n == 0:
                    name = line.split('\t')[1][:-1]

                if n is state_index:
                    state = line.split('\t')[1][0]
                    continue

                if n is ppid_index:
                    ppid = line.split('\t')[1][:-1]
                    continue

                if n is uid_index:
                    uid = line.split('\t')[2]
                    continue

                if n is vm_size_index:
                    vm_size = kib_to_mib(int(line.split('\t')[1][:-4]))
                    continue

                if n is vm_rss_index:
                    vm_rss = kib_to_mib(int(line.split('\t')[1][:-4]))
                    continue

                if n is vm_swap_index:
                    vm_swap = kib_to_mib(int(line.split('\t')[1][:-4]))
                    break

        return name, state, ppid, uid, vm_size, vm_rss, vm_swap

    except UnicodeDecodeError:
        return pid_to_status_unicode(pid)

    except FileNotFoundError:
        return None

    except ProcessLookupError:
        return None

    except ValueError:
        return None


def pid_to_status_unicode(pid):
    """
    """
    try:

        with open('/proc/' + pid + '/status', 'rb') as f:
            f_list = f.read().decode('utf-8', 'ignore').split('\n')

            for i in range(len(f_list)):

                if i == 0:
                    name = f_list[i].split('\t')[1]

                if i is state_index:
                    state = f_list[i].split('\t')[1][0]

                if i is ppid_index:
                    ppid = f_list[i].split('\t')[1]

                if i is uid_index:
                    uid = f_list[i].split('\t')[2]

                if i is vm_size_index:
                    vm_size = kib_to_mib(
                        int(f_list[i].split('\t')[1][:-3]))

                if i is vm_rss_index:
                    vm_rss = kib_to_mib(int(f_list[i].split('\t')[1][:-3]))

                if i is vm_swap_index:
                    vm_swap = kib_to_mib(int(f_list[i].split('\t')[1][:-3]))

        return name, state, ppid, uid, vm_size, vm_rss, vm_swap

    except FileNotFoundError:
        return None

    except ProcessLookupError:
        return None

    except ValueError:
        return None


def pid_to_badness(pid):
    """Find and modify badness (if it needs)."""

    try:

        oom_score = int(rline1('/proc/' + pid + '/oom_score'))
        badness = oom_score

        """

        Новое:
        запрет на повышение бэднес если


        """

        if ignore_positive_oom_score_adj:
            oom_score_adj = int(rline1('/proc/' + pid + '/oom_score_adj'))
            if oom_score_adj > 0:
                badness = badness - oom_score_adj

        if regex_matching:
            name = pid_to_name(pid)
            for re_tup in badness_adj_re_name_list:
                if search(re_tup[1], name) is not None:
                    badness += int(re_tup[0])

        if re_match_cgroup_systemd:
            cgroup_systemd = pid_to_cgroup_systemd(pid)
            for re_tup in badness_adj_re_cgroup_systemd_list:
                if search(re_tup[1], cgroup_systemd) is not None:
                    badness += int(re_tup[0])

        if re_match_cgroup_unified:
            cgroup_unified = pid_to_cgroup_unified(pid)
            for re_tup in badness_adj_re_cgroup_unified_list:
                if search(re_tup[1], cgroup_unified) is not None:
                    badness += int(re_tup[0])

        if re_match_realpath:
            realpath = pid_to_realpath(pid)
            for re_tup in badness_adj_re_realpath_list:
                if search(re_tup[1], realpath) is not None:
                    badness += int(re_tup[0])

        if re_match_cwd:
            cwd = pid_to_cwd(pid)
            for re_tup in badness_adj_re_cwd_list:
                if search(re_tup[1], cwd) is not None:
                    badness += int(re_tup[0])

        if re_match_cmdline:
            cmdline = pid_to_cmdline(pid)
            for re_tup in badness_adj_re_cmdline_list:
                if search(re_tup[1], cmdline) is not None:
                    badness += int(re_tup[0])

        if re_match_environ:
            environ = pid_to_environ(pid)
            for re_tup in badness_adj_re_environ_list:
                if search(re_tup[1], environ) is not None:
                    badness += int(re_tup[0])

        if re_match_uid:
            uid = pid_to_uid(pid)
            for re_tup in badness_adj_re_uid_list:
                if search(re_tup[1], uid) is not None:
                    badness += int(re_tup[0])

        if badness < 0:
            badness = 0

        return badness, oom_score

    except FileNotFoundError:
        return None, None
    except ProcessLookupError:
        return None, None


def get_victim_id(pid):
    """victim_id is starttime + pid"""
    try:
        return rline1('/proc/' + pid + '/stat').rpartition(
            ')')[2].split(' ')[20] + ':' + pid
    except FileNotFoundError:
        return ''
    except ProcessLookupError:
        return ''


def is_victim_alive(victim_id):
    """
    We do not have a reliable sign of the end of the release of memory:
    https://github.com/rfjakob/earlyoom/issues/128#issuecomment-507023717

    Варианты возврата:
    0 X, nonexist, другой процесс (полн конец имплементации, можно не делать POST SIGKILL DELAY)
    1 rp true
    2 R освобождает память. Ждем смерти.
    3 Z возможно уже освободил память. Конец отслеживания
    """

    # Проверка целостности жертвы
    starttime, pid = victim_id.split(':')
    new_victim_id = get_victim_id(pid)
    if victim_id != new_victim_id:
        return 'X'

    # Жива ли жертва?
    exe_exists = os.path.exists('/proc/{}/exe'.format(pid))
    if exe_exists:
        return 'E'

    # далее жертва смертельно ранена. Дифференцируемся по State.
    # R -> 2 # отслеживать жертву дальше
    # X, FNFE, PLE -> 0

    state = pid_to_state(pid)

    if state == 'R':
        return 'R'

    if state == 'Z':
        return 'Z'

    if state == 'X' or state == '':
        return 'X'

    return 'X'


def is_unkillable(pid):
    """
    """
    try:
        osa = rline1('/proc/{}/oom_score_adj'.format(pid))
        if osa == '-1000':
            i = True
        else:
            i = False
        #print('osa', osa, i)
    except FileNotFoundError:
        i = True
    except ProcessLookupError:
        i = True
    return i


def find_victim_info(pid, victim_badness, name):
    """
    """
    status0 = monotonic()

    try:

        with open('/proc/' + pid + '/status') as f:

            for n, line in enumerate(f):

                if n is state_index:
                    state = line.split('\t')[1].rstrip()
                    continue

                """
                if n is ppid_index:
                    # ppid = line.split('\t')[1]
                    continue
                """

                if n is uid_index:
                    uid = line.split('\t')[2]
                    continue

                if n is vm_size_index:
                    vm_size = kib_to_mib(int(line.split('\t')[1][:-4]))
                    continue

                if n is vm_rss_index:
                    vm_rss = kib_to_mib(int(line.split('\t')[1][:-4]))
                    continue

                if detailed_rss:

                    if n is anon_index:
                        anon_rss = kib_to_mib(
                            int(line.split('\t')[1][:-4]))
                        continue

                    if n is file_index:
                        file_rss = kib_to_mib(
                            int(line.split('\t')[1][:-4]))
                        continue

                    if n is shmem_index:
                        shmem_rss = kib_to_mib(
                            int(line.split('\t')[1][:-4]))
                        continue

                if n is vm_swap_index:
                    vm_swap = kib_to_mib(int(line.split('\t')[1][:-4]))
                    break

        if print_victim_cmdline:
            cmdline = pid_to_cmdline(pid)
        oom_score = rline1('/proc/' + pid + '/oom_score')
        oom_score_adj = rline1('/proc/' + pid + '/oom_score_adj')

    except FileNotFoundError:
        log('The victim died in the search process: FileNotFoundError')
        update_stat_dict_and_print(
            'The victim died in the search process: FileNotFoundError')
        return None
    except ProcessLookupError:
        log('The victim died in the search process: ProcessLookupError')
        update_stat_dict_and_print(
            'The victim died in the search process: ProcessLookupError')
        return None
    except UnicodeDecodeError:

        with open('/proc/' + pid + '/status', 'rb') as f:
            f_list = f.read().decode('utf-8', 'ignore').split('\n')

            for i in range(len(f_list)):

                if i is state_index:
                    state = f_list[i].split('\t')[1].rstrip()

                """
                if i is ppid_index:
                    pass
                    # ppid = f_list[i].split('\t')[1]
                """

                if i is uid_index:
                    uid = f_list[i].split('\t')[2]

                if i is vm_size_index:
                    vm_size = kib_to_mib(
                        int(f_list[i].split('\t')[1][:-3]))

                if i is vm_rss_index:
                    vm_rss = kib_to_mib(int(f_list[i].split('\t')[1][:-3]))

                if detailed_rss:

                    if i is anon_index:
                        anon_rss = kib_to_mib(
                            int(f_list[i].split('\t')[1][:-3]))

                    if i is file_index:
                        file_rss = kib_to_mib(
                            int(f_list[i].split('\t')[1][:-3]))

                    if i is shmem_index:
                        shmem_rss = kib_to_mib(
                            int(f_list[i].split('\t')[1][:-3]))

                if i is vm_swap_index:
                    vm_swap = kib_to_mib(
                        int(f_list[i].split('\t')[1][:-3]))

        if print_victim_cmdline:
            cmdline = pid_to_cmdline(pid)
        oom_score = rline1('/proc/' + pid + '/oom_score')
        oom_score_adj = rline1('/proc/' + pid + '/oom_score_adj')

    except IndexError:
        log('The victim died in the search process: IndexError')
        update_stat_dict_and_print(
            'The victim died in the search process: IndexError')
        return None
    except ValueError:
        log('The victim died in the search process: ValueError')
        update_stat_dict_and_print(
            'The victim died in the search process: ValueError')
        return None
    except FileNotFoundError:
        log('The victim died in the search process: FileNotFoundError')
        update_stat_dict_and_print(
            'The victim died in the search process: FileNotFoundError')
        return None
    except ProcessLookupError:
        log('The victim died in the search process: ProcessLookupError')
        update_stat_dict_and_print(
            'The victim died in the search process: ProcessLookupError')
        return None

    len_vm = len(str(vm_size))

    try:
        realpath = os.path.realpath('/proc/' + pid + '/exe')

        cwd = os.path.realpath('/proc/' + pid + '/cwd')

        sid = pid_to_sid(pid)

        victim_lifetime = format_time(uptime() - pid_to_starttime(pid))
        victim_cgroup_systemd = pid_to_cgroup_systemd(pid)
        victim_cgroup_unified = pid_to_cgroup_unified(pid)

    except FileNotFoundError:
        log('The victim died in the search process: FileNotFoundError')
        update_stat_dict_and_print(
            'The victim died in the search process: FileNotFoundError')
        return None

    ancestry = pid_to_ancestry(pid, max_victim_ancestry_depth)

    if print_victim_cmdline is False:
        cmdline = ''
        c1 = ''
    else:
        c1 = '\n  Cmdline:   '

    if detailed_rss:
        detailed_rss_info = ' (' \
            'Anon: {} MiB, ' \
            'File: {} MiB, ' \
            'Shmem: {} MiB)'.format(
                anon_rss,
                file_rss,
                shmem_rss)
    else:
        detailed_rss_info = ''

    victim_info = 'Victim status (found in {} ms):' \
        '\n  Name:      {}' \
        '\n  State:     {}' \
        '\n  PID:       {}' \
        '\n{}' \
        '\n  EUID:      {}' \
        '\n  badness:   {}, ' \
        'oom_score:  {}, ' \
        'oom_score_adj:  {}' \
        '\n  VmSize:    {} MiB' \
        '\n  VmRSS:     {} MiB {}' \
        '\n  VmSwap:    {} MiB' \
        '\n  CGroup_systemd: {}' \
        '\n  CGroup_unified: {}' \
        '\n  SID:       {} ({})' \
        '\n  Realpath:  {}' \
        '\n  Cwd:       {}' \
        '{}{}' \
        '\n  Lifetime:  {}'.format(
            round((monotonic() - status0) * 1000),
            name,
            state,
            pid,
            ancestry,
            uid,
            victim_badness,
            oom_score,
            oom_score_adj,
            vm_size,
            str(vm_rss).rjust(len_vm),
            detailed_rss_info,
            str(vm_swap).rjust(len_vm),
            victim_cgroup_systemd,
            victim_cgroup_unified,
            sid, pid_to_name(sid),
            realpath,
            cwd,
            c1, cmdline,
            victim_lifetime)

    return victim_info













###########################################################################################################################
###########################################################################################################################
###########################################################################################################################
###########################################################################################################################
###########################################################################################################################










start_time = monotonic()


help_mess = """usage: nohang [-h] [-v] [-p] [-c CONFIG] [-cc CONFIG]

optional arguments:
  -h, --help            show this help message and exit
  -v, --version         print version
  -p, --print-proc-table
                        print table of processes with their badness values
  -c CONFIG, --config CONFIG
                        path to the config file, default values:
                        ./nohang.conf, /etc/nohang/nohang.conf
  -cc CONFIG, --check-config CONFIG
                        check and print config"""


SC_CLK_TCK = os.sysconf(os.sysconf_names['SC_CLK_TCK'])

SC_PAGESIZE = os.sysconf(os.sysconf_names['SC_PAGESIZE'])  # Используется ли?

# Переделать всё это: ERROR: invalid config: ...
conf_err_mess = 'Invalid config. Exit.'

sig_list = [SIGTERM, SIGINT, SIGQUIT, SIGHUP]

sig_dict = {
    SIGKILL: 'SIGKILL',
    SIGINT: 'SIGINT',
    SIGQUIT: 'SIGQUIT',
    SIGHUP: 'SIGHUP',
    SIGTERM: 'SIGTERM'
}

self_pid = str(os.getpid())

self_uid = os.geteuid()

if self_uid == 0:
    root = True
else:
    root = False


if os.path.exists('./nohang_notify_helper'):
    notify_helper_path = './nohang_notify_helper'
else:
    notify_helper_path = 'nohang_notify_helper'


# {victim_id : {'time': timestamp, 'name': name}
v_dict = dict()


last_action_dict = dict()

last_action_dict['t'] = monotonic()


# will store corrective actions stat
stat_dict = dict()


separate_log = False  # will be overwritten after parse config


cgroup_systemd_index, cgroup_unified_index = find_cgroup_indexes()


pid_list = get_pid_list()

non_decimal_list = get_non_decimal_pids()


print_proc_table_flag = False

check_config_flag = False


if os.path.exists('./nohang.conf'):
    config = os.getcwd() + '/nohang.conf'
else:
    config = '/etc/nohang/nohang.conf'


if len(argv) == 1:
    pass
elif len(argv) == 2:
    if argv[1] == '--help' or argv[1] == '-h':
        print(help_mess)
        exit()
    elif argv[1] == '--check-config' or argv[1] == '-cc':
        check_config_flag = True
    elif argv[1] == '--version' or argv[1] == '-v':
        print_version()
    elif argv[1] == '--print-proc-table' or argv[1] == '-p':
        print_proc_table_flag = True
        if os.path.exists('./nohang.conf'):
            config = os.getcwd() + '/nohang.conf'
        else:
            config = '/etc/nohang/nohang.conf'
    else:
        errprint('Unknown option: {}'.format(argv[1]))
        exit(1)
elif len(argv) == 3:
    if argv[1] == '--config' or argv[1] == '-c':
        config = argv[2]
    elif argv[1] == '--check-config' or argv[1] == '-cc':
        config = argv[2]
        check_config_flag = True
    else:
        errprint('Unknown option: {}'.format(argv[1]))
        exit(1)
else:
    errprint('Invalid CLI input: too many options')
    exit(1)


# find mem_total
# find positions of SwapFree and SwapTotal in /proc/meminfo

with open('/proc/meminfo') as f:
    mem_list = f.readlines()

mem_list_names = []
for s in mem_list:
    mem_list_names.append(s.split(':')[0])

if mem_list_names[2] != 'MemAvailable':
    errprint('WARNING: Your Linux kernel is too old, Linux 3.14+ requied')
    exit(1)

swap_total_index = mem_list_names.index('SwapTotal')
swap_free_index = swap_total_index + 1

mem_total = int(mem_list[0].split(':')[1][:-4])

# Get names from /proc/*/status to be able to get VmRSS and VmSwap values

with open('/proc/self/status') as file:
    status_list = file.readlines()

status_names = []
for s in status_list:
    status_names.append(s.split(':')[0])

ppid_index = status_names.index('PPid')
vm_size_index = status_names.index('VmSize')
vm_rss_index = status_names.index('VmRSS')
vm_swap_index = status_names.index('VmSwap')
uid_index = status_names.index('Uid')
state_index = status_names.index('State')


try:
    anon_index = status_names.index('RssAnon')
    file_index = status_names.index('RssFile')
    shmem_index = status_names.index('RssShmem')
    detailed_rss = True
    # print(detailed_rss, 'detailed_rss')
except ValueError:
    detailed_rss = False
    # print('It is not Linux 4.5+')


log('config: ' + config)


###############################################################################


# parsing the config with obtaining the parameters dictionary

# conf_parameters_dict
# conf_restart_dict

# dictionary with config options
config_dict = dict()

badness_adj_re_name_list = []
badness_adj_re_cmdline_list = []
badness_adj_re_environ_list = []
badness_adj_re_uid_list = []
badness_adj_re_cgroup_systemd_list = []
badness_adj_re_cgroup_unified_list = []
badness_adj_re_realpath_list = []

badness_adj_re_cwd_list = []


soft_actions_list = []

kill_session_regex_sid_name_list = []

custom_action_re_cgroup_unified_list = []
custom_action_re_cgroup_systemd_list = []


# separator for optional parameters (that starts with @)
opt_separator = '///'
kill_group_separator = '[KILL_GROUP]'

# stupid conf parsing, need refactoring
try:
    with open(config) as f:

        for line in f:

            a = line.startswith('#')
            b = line.startswith('\n')
            c = line.startswith('\t')
            d = line.startswith(' ')

            etc = line.startswith('@SOFT_ACTION_RE_NAME')
            etc2 = line.startswith('@SOFT_ACTION_RE_CGROUP_SYSTEMD')
            etc3 = line.startswith('@KILL_SESSION_REGEX_SID_NAME')

            etc4 = line.startswith('@CUSTOM_ACTION_RE_CGROUP_UNIFIED')
            etc5 = line.startswith('@CUSTOM_ACTION_RE_CGROUP_SYSTEMD')

            if not a and not b and not c and not d and not etc and not etc2 and not etc3 and not etc4 and not etc5:
                a = line.partition('=')

                key = a[0].strip()
                value = a[2].strip()

                if key not in config_dict:
                    config_dict[key] = value
                else:
                    log('ERROR: config key duplication: {}'.format(key))
                    exit(1)

            if etc:

                a = line.partition('@SOFT_ACTION_RE_NAME')[
                    2].partition(opt_separator)

                a1 = 'name'

                a2 = a[0].strip()
                valid_re(a2)

                a3 = a[2].strip()

                zzz = (a1, a2, a3)

                soft_actions_list.append(zzz)

            if etc2:

                a = line.partition('@SOFT_ACTION_RE_CGROUP_SYSTEMD')[
                    2].partition(opt_separator)

                a1 = 'cgroup_systemd'

                a2 = a[0].strip()
                valid_re(a2)

                a3 = a[2].strip()

                zzz = (a1, a2, a3)

                soft_actions_list.append(zzz)

            if etc3:

                a = line.partition('@KILL_SESSION_REGEX_SID_NAME')

                kill_session_regex_sid_name_list.append(a[2].strip())

            if etc4:
                a = line.partition('@CUSTOM_ACTION_RE_CGROUP_UNIFIED')
                b = a[2].strip()
                if opt_separator in b:
                    b = b.partition(opt_separator)
                    rega = b[0].strip()
                    cmd = b[2].strip()
                    if cmd.startswith(kill_group_separator):
                        kill = True
                        cmd = cmd.partition(kill_group_separator)[2].strip()
                    else:
                        kill = False
                    custom_action_re_cgroup_unified_list.append(
                        (rega, kill, cmd))

            if etc5:
                a = line.partition('@CUSTOM_ACTION_RE_CGROUP_SYSTEMD')
                b = a[2].strip()
                if opt_separator in b:
                    b = b.partition(opt_separator)
                    rega = b[0].strip()
                    cmd = b[2].strip()
                    if cmd.startswith(kill_group_separator):
                        kill = True
                        cmd = cmd.partition(kill_group_separator)[2].strip()
                    else:
                        kill = False
                    custom_action_re_cgroup_systemd_list.append(
                        (rega, kill, cmd))

            if line.startswith('@BADNESS_ADJ_RE_NAME'):
                a = line.partition('@BADNESS_ADJ_RE_NAME')[2].strip(
                    ' \n').partition(opt_separator)
                badness_adj = a[0].strip(' ')
                reg_exp = a[2].strip(' ')
                valid_re(reg_exp)
                badness_adj_re_name_list.append((badness_adj, reg_exp))

            if line.startswith('@BADNESS_ADJ_RE_CMDLINE'):
                a = line.partition('@BADNESS_ADJ_RE_CMDLINE')[2].strip(
                    ' \n').partition(opt_separator)
                badness_adj = a[0].strip(' ')
                reg_exp = a[2].strip(' ')
                valid_re(reg_exp)
                badness_adj_re_cmdline_list.append((badness_adj, reg_exp))

            if line.startswith('@BADNESS_ADJ_RE_UID'):
                a = line.partition('@BADNESS_ADJ_RE_UID')[2].strip(
                    ' \n').partition(opt_separator)
                badness_adj = a[0].strip(' ')
                reg_exp = a[2].strip(' ')
                valid_re(reg_exp)
                badness_adj_re_uid_list.append((badness_adj, reg_exp))

            if line.startswith('@BADNESS_ADJ_RE_CGROUP_SYSTEMD'):
                a = line.partition('@BADNESS_ADJ_RE_CGROUP_SYSTEMD')[2].strip(
                    ' \n').partition(opt_separator)
                badness_adj = a[0].strip(' ')
                reg_exp = a[2].strip(' ')
                valid_re(reg_exp)
                badness_adj_re_cgroup_systemd_list.append(
                    (badness_adj, reg_exp))

            if line.startswith('@BADNESS_ADJ_RE_CGROUP_UNIFIED'):
                a = line.partition('@BADNESS_ADJ_RE_CGROUP_UNIFIED')[2].strip(
                    ' \n').partition(opt_separator)
                badness_adj = a[0].strip(' ')
                reg_exp = a[2].strip(' ')
                valid_re(reg_exp)
                badness_adj_re_cgroup_unified_list.append(
                    (badness_adj, reg_exp))

            if line.startswith('@BADNESS_ADJ_RE_REALPATH'):
                a = line.partition('@BADNESS_ADJ_RE_REALPATH')[2].strip(
                    ' \n').partition(opt_separator)
                badness_adj = a[0].strip(' ')
                reg_exp = a[2].strip(' ')
                valid_re(reg_exp)
                badness_adj_re_realpath_list.append((badness_adj, reg_exp))

            if line.startswith('@BADNESS_ADJ_RE_CWD'):
                a = line.partition('@BADNESS_ADJ_RE_CWD')[2].strip(
                    ' \n').partition(opt_separator)
                badness_adj = a[0].strip(' ')
                reg_exp = a[2].strip(' ')
                valid_re(reg_exp)
                badness_adj_re_cwd_list.append((badness_adj, reg_exp))

            if line.startswith('@BADNESS_ADJ_RE_ENVIRON'):
                a = line.partition('@BADNESS_ADJ_RE_ENVIRON')[2].strip(
                    ' \n').partition(opt_separator)
                badness_adj = a[0].strip(' ')
                reg_exp = a[2].strip(' ')
                valid_re(reg_exp)
                badness_adj_re_environ_list.append((badness_adj, reg_exp))


except PermissionError:
    errprint('PermissionError', conf_err_mess)
    exit(1)
except UnicodeDecodeError:
    errprint('UnicodeDecodeError', conf_err_mess)
    exit(1)
except IsADirectoryError:
    errprint('IsADirectoryError', conf_err_mess)
    exit(1)
except IndexError:
    errprint('IndexError', conf_err_mess)
    exit(1)
except FileNotFoundError:
    errprint('FileNotFoundError', conf_err_mess)
    exit(1)


if badness_adj_re_name_list == []:
    regex_matching = False
else:
    regex_matching = True


if badness_adj_re_cmdline_list == []:
    re_match_cmdline = False
else:
    re_match_cmdline = True


if badness_adj_re_uid_list == []:
    re_match_uid = False
else:
    re_match_uid = True


if badness_adj_re_environ_list == []:
    re_match_environ = False
else:
    re_match_environ = True


if badness_adj_re_realpath_list == []:
    re_match_realpath = False
else:
    re_match_realpath = True


if badness_adj_re_cwd_list == []:
    re_match_cwd = False
else:
    re_match_cwd = True


if badness_adj_re_cgroup_systemd_list == []:
    re_match_cgroup_systemd = False
else:
    re_match_cgroup_systemd = True


if badness_adj_re_cgroup_unified_list == []:
    re_match_cgroup_unified = False
else:
    re_match_cgroup_unified = True


if soft_actions_list == []:
    soft_actions = False
else:
    soft_actions = True


if kill_session_regex_sid_name_list == []:
    kill_session_enabled = False
else:
    kill_session_enabled = True


if custom_action_re_cgroup_unified_list == []:
    custom_action_re_cgroup_unified = False
else:
    custom_action_re_cgroup_unified = True


print(custom_action_re_cgroup_unified_list, custom_action_re_cgroup_unified)


if custom_action_re_cgroup_systemd_list == []:
    custom_action_re_cgroup_systemd = False
else:
    custom_action_re_cgroup_systemd = True


print(custom_action_re_cgroup_systemd_list, custom_action_re_cgroup_systemd)


###############################################################################


# extracting parameters from the dictionary
# check for all necessary parameters
# validation of all parameters
debug_psi = conf_parse_bool('debug_psi')
print_statistics = conf_parse_bool('print_statistics')
print_proc_table = conf_parse_bool('print_proc_table')
###############################################################################
# 3


print_victim_status = conf_parse_bool('print_victim_status')
print_victim_cmdline = conf_parse_bool('print_victim_cmdline')
print_config_at_startup = conf_parse_bool('print_config_at_startup')
print_mem_check_results = conf_parse_bool('print_mem_check_results')
debug_sleep = conf_parse_bool('debug_sleep')


kill_shell_sessions_group = conf_parse_bool('kill_shell_sessions_group')


max_kill_wait_time = conf_parse_bool('max_kill_wait_time')


hide_corrective_action_type = conf_parse_bool('hide_corrective_action_type')


low_memory_warnings_enabled = conf_parse_bool('low_memory_warnings_enabled')


post_action_gui_notifications = conf_parse_bool(
    'post_action_gui_notifications')


debug_threading = conf_parse_bool('debug_threading')


psi_checking_enabled = conf_parse_bool('psi_checking_enabled')
ignore_psi = not psi_checking_enabled

zram_checking_enabled = conf_parse_bool('zram_checking_enabled')
ignore_zram = not zram_checking_enabled


debug_gui_notifications = conf_parse_bool('debug_gui_notifications')
ignore_positive_oom_score_adj = conf_parse_bool(
    'ignore_positive_oom_score_adj')


(soft_threshold_min_mem_kb, soft_threshold_min_mem_mb,
 soft_threshold_min_mem_percent) = calculate_percent('soft_threshold_min_mem')

(hard_threshold_min_mem_kb, hard_threshold_min_mem_mb,
 hard_threshold_min_mem_percent) = calculate_percent('hard_threshold_min_mem')

(soft_threshold_max_zram_kb, soft_threshold_max_zram_mb,
 soft_threshold_max_zram_percent) = calculate_percent('soft_threshold_max_zram')

(hard_threshold_max_zram_kb, hard_threshold_max_zram_mb,
 hard_threshold_max_zram_percent) = calculate_percent('hard_threshold_max_zram')

(warning_threshold_min_mem_kb, warning_threshold_min_mem_mb,
 warning_threshold_min_mem_percent) = calculate_percent('warning_threshold_min_mem')

(warning_threshold_max_zram_kb, warning_threshold_max_zram_mb,
 warning_threshold_max_zram_percent) = calculate_percent('warning_threshold_max_zram')


if 'post_zombie_delay' in config_dict:
    post_zombie_delay = string_to_float_convert_test(
        config_dict['post_zombie_delay'])
    if post_zombie_delay is None:
        errprint('Invalid post_zombie_delay, not float\nExit')
        exit(1)
    if post_zombie_delay < 0:
        errprint('post_zombie_delay MUST be >= 0\nExit')
        exit(1)
else:
    errprint('post_zombie_delay not in config\nExit')
    exit(1)


if 'victim_cache_time' in config_dict:
    victim_cache_time = string_to_float_convert_test(
        config_dict['victim_cache_time'])
    if victim_cache_time is None:
        errprint('Invalid victim_cache_time, not float\nExit')
        exit(1)
    if victim_cache_time < 0:
        errprint('victim_cache_time MUST be >= 0\nExit')
        exit(1)
else:
    errprint('victim_cache_time not in config\nExit')
    exit(1)


if 'env_cache_time' in config_dict:
    env_cache_time = string_to_float_convert_test(
        config_dict['env_cache_time'])
    if env_cache_time is None:
        errprint('Invalid env_cache_time value, not float\nExit')
        exit(1)
    if env_cache_time < 0:
        errprint('env_cache_time MUST be >= 0\nExit')
        exit(1)
else:
    errprint('env_cache_time not in config\nExit')
    exit(1)


if 'exe_timeout' in config_dict:
    exe_timeout = string_to_float_convert_test(
        config_dict['exe_timeout'])
    if exe_timeout is None:
        errprint('Invalid exe_timeout value, not float\nExit')
        exit(1)
    if exe_timeout <= 0:
        errprint('exe_timeout MUST be > 0\nExit')
        exit(1)
else:
    errprint('exe_timeout not in config\nExit')
    exit(1)


if 'fill_rate_mem' in config_dict:
    fill_rate_mem = string_to_float_convert_test(config_dict['fill_rate_mem'])
    if fill_rate_mem is None:
        errprint('Invalid fill_rate_mem value, not float\nExit')
        exit(1)
    if fill_rate_mem <= 0:
        errprint('fill_rate_mem MUST be > 0\nExit')
        exit(1)
else:
    errprint('fill_rate_mem not in config\nExit')
    exit(1)


if 'fill_rate_swap' in config_dict:
    fill_rate_swap = string_to_float_convert_test(
        config_dict['fill_rate_swap'])
    if fill_rate_swap is None:
        errprint('Invalid fill_rate_swap value, not float\nExit')
        exit(1)
    if fill_rate_swap <= 0:
        errprint('fill_rate_swap MUST be > 0\nExit')
        exit(1)
else:
    errprint('fill_rate_swap not in config\nExit')
    exit(1)


if 'fill_rate_zram' in config_dict:
    fill_rate_zram = string_to_float_convert_test(
        config_dict['fill_rate_zram'])
    if fill_rate_zram is None:
        errprint('Invalid fill_rate_zram value, not float\nExit')
        exit(1)
    if fill_rate_zram <= 0:
        errprint('fill_rate_zram MUST be > 0\nExit')
        exit(1)
else:
    errprint('fill_rate_zram not in config\nExit')
    exit(1)


if 'soft_threshold_min_swap' in config_dict:
    soft_threshold_min_swap = config_dict['soft_threshold_min_swap']
else:
    errprint('soft_threshold_min_swap not in config\nExit')
    exit(1)


if 'hard_threshold_min_swap' in config_dict:
    hard_threshold_min_swap = config_dict['hard_threshold_min_swap']
else:
    errprint('hard_threshold_min_swap not in config\nExit')
    exit(1)


if 'post_soft_action_delay' in config_dict:
    post_soft_action_delay = string_to_float_convert_test(
        config_dict['post_soft_action_delay'])
    if post_soft_action_delay is None:
        errprint('Invalid post_soft_action_delay value, not float\nExit')
        exit(1)
    if post_soft_action_delay < 0:
        errprint('post_soft_action_delay must be positiv\nExit')
        exit(1)
else:
    errprint('post_soft_action_delay not in config\nExit')
    exit(1)


if 'psi_post_action_delay' in config_dict:
    psi_post_action_delay = string_to_float_convert_test(
        config_dict['psi_post_action_delay'])
    if psi_post_action_delay is None:
        errprint('Invalid psi_post_action_delay value, not float\nExit')
        exit(1)
    if psi_post_action_delay < 0:
        errprint('psi_post_action_delay must be positive\nExit')
        exit(1)
else:
    errprint('psi_post_action_delay not in config\nExit')
    exit(1)


if 'hard_threshold_max_psi' in config_dict:
    hard_threshold_max_psi = string_to_float_convert_test(
        config_dict['hard_threshold_max_psi'])
    if hard_threshold_max_psi is None:
        errprint('Invalid hard_threshold_max_psi value, not float\nExit')
        exit(1)
    if hard_threshold_max_psi < 0 or hard_threshold_max_psi > 100:
        errprint('hard_threshold_max_psi must be in the range [0; 100]\nExit')
        exit(1)
else:
    errprint('hard_threshold_max_psi not in config\nExit')
    exit(1)


if 'soft_threshold_max_psi' in config_dict:
    soft_threshold_max_psi = string_to_float_convert_test(
        config_dict['soft_threshold_max_psi'])
    if soft_threshold_max_psi is None:
        errprint('Invalid soft_threshold_max_psi value, not float\nExit')
        exit(1)
    if soft_threshold_max_psi < 0 or soft_threshold_max_psi > 100:
        errprint('soft_threshold_max_psi must be in the range [0; 100]\nExit')
        exit(1)
else:
    errprint('soft_threshold_max_psi not in config\nExit')
    exit(1)


if 'warning_threshold_max_psi' in config_dict:
    warning_threshold_max_psi = string_to_float_convert_test(
        config_dict['warning_threshold_max_psi'])
    if warning_threshold_max_psi is None:
        errprint('Invalid warning_threshold_max_psi value, not float\nExit')
        exit(1)
    if warning_threshold_max_psi < 0 or warning_threshold_max_psi > 100:
        errprint(
            'warning_threshold_max_psi must be in the range [0; 100]\nExit')
        exit(1)
else:
    errprint('warning_threshold_max_psi not in config\nExit')
    exit(1)


if 'min_badness' in config_dict:
    min_badness = string_to_int_convert_test(
        config_dict['min_badness'])
    if min_badness is None:
        errprint('Invalid min_badness value, not integer\nExit')
        exit(1)
    if min_badness < 0 or min_badness > 1000:
        errprint('Invalud min_badness value\nExit')
        exit(1)
else:
    errprint('min_badness not in config\nExit')
    exit(1)


if 'min_post_warning_delay' in config_dict:
    min_post_warning_delay = string_to_float_convert_test(
        config_dict['min_post_warning_delay'])
    if min_post_warning_delay is None:
        errprint('Invalid min_post_warning_delay value, not float\nExit')
        exit(1)
    if min_post_warning_delay < 1 or min_post_warning_delay > 300:
        errprint('min_post_warning_delay value out of range [1; 300]\nExit')
        exit(1)
else:
    errprint('min_post_warning_delay not in config\nExit')
    exit(1)


if 'warning_threshold_min_swap' in config_dict:
    warning_threshold_min_swap = config_dict['warning_threshold_min_swap']
else:
    errprint('warning_threshold_min_swap not in config\nExit')
    exit(1)


if 'max_victim_ancestry_depth' in config_dict:
    max_victim_ancestry_depth = string_to_int_convert_test(
        config_dict['max_victim_ancestry_depth'])
    if min_badness is None:
        errprint('Invalid max_victim_ancestry_depth value, not integer\nExit')
        exit(1)
    if max_victim_ancestry_depth < 1:
        errprint('Invalud max_victim_ancestry_depth value\nExit')
        exit(1)
else:
    errprint('max_victim_ancestry_depth is not in config\nExit')
    exit(1)


if 'max_soft_exit_time' in config_dict:
    max_soft_exit_time = string_to_float_convert_test(
        config_dict['max_soft_exit_time'])
    if max_soft_exit_time is None:
        errprint('Invalid max_soft_exit_time val'
                 'ue, not float\nExit')
        exit(1)
    if max_soft_exit_time < 0:
        errprint('max_soft_exit_time must be non-n'
                 'egative number\nExit')
        exit(1)
else:
    errprint('max_soft_exit_time is not in config\nExit')
    exit(1)


if 'psi_path' in config_dict:
    psi_path = config_dict['psi_path']
else:
    errprint('psi_path is not in config\nExit')
    exit(1)


if 'psi_metrics' in config_dict:
    psi_metrics = config_dict['psi_metrics']
else:
    errprint('psi_metrics is not in config\nExit')
    exit(1)


if 'warning_exe' in config_dict:
    warning_exe = config_dict['warning_exe']
    if warning_exe != '':
        check_warning_exe = True
    else:
        check_warning_exe = False
else:
    errprint('warning_exe is not in config\nExit')
    exit(1)


if 'extra_table_info' in config_dict:
    extra_table_info = config_dict['extra_table_info']
    if (extra_table_info != 'None' and
        extra_table_info != 'cgroup_systemd' and
        extra_table_info != 'cgroup_unified' and
        extra_table_info != 'cmdline' and
        extra_table_info != 'environ' and
            extra_table_info != 'realpath' and extra_table_info != 'cwd'):

        errprint('Invalid config: invalid extra_table_info value\nExit')
        exit(1)
else:
    errprint('Invalid config: extra_table_info is not in config\nExit')
    exit(1)


separate_log = conf_parse_bool('separate_log')

if separate_log:

    import logging

    log_dir = '/var/log/nohang'
    logfile = log_dir + '/nohang.log'

    try:
        os.mkdir(log_dir)
    except FileExistsError:
        pass
    except PermissionError:
        errprint('ERROR: cannot create {}'.format(log_dir))

    try:
        os.chmod(log_dir, mode=0o750)
    except FileNotFoundError:
        errprint('ERROR: file not found: {}'.format(log_dir))
    except PermissionError:
        errprint('ERROR: permission denied: {}'.format(log_dir))

    try:
        logging.basicConfig(
            filename=logfile,
            level=logging.INFO,
            format="%(asctime)s: %(message)s")
    except FileNotFoundError:
        errprint('ERROR: file not found: {}'.format(logfile))
    except PermissionError:
        errprint('ERROR: permission denied: {}'.format(logfile))


if 'min_mem_report_interval' in config_dict:
    min_mem_report_interval = string_to_float_convert_test(
        config_dict['min_mem_report_interval'])
    if min_mem_report_interval is None:
        errprint('Invalid min_mem_report_interval value, not float\nExit')
        exit(1)
    if min_mem_report_interval < 0:
        errprint('min_mem_report_interval must be non-negative number\nExit')
        exit(1)
else:
    errprint('min_mem_report_interval is not in config\nExit')
    exit(1)


if 'psi_excess_duration' in config_dict:
    psi_excess_duration = string_to_float_convert_test(
        config_dict['psi_excess_duration'])
    if psi_excess_duration is None:
        errprint('Invalid psi_excess_duration value, not float\nExit')
        exit(1)
    if psi_excess_duration < 0:
        errprint('psi_excess_duration must be non-negative number\nExit')
        exit(1)
else:
    errprint('psi_excess_duration is not in config\nExit')
    exit(1)


if 'max_sleep' in config_dict:
    max_sleep = string_to_float_convert_test(
        config_dict['max_sleep'])
    if max_sleep is None:
        errprint('Invalid max_sleep value, not float\nExit')
        exit(1)
    if max_sleep <= 0:
        errprint('max_sleep must be positive number\nExit')
        exit(1)
else:
    errprint('max_sleep is not in config\nExit')
    exit(1)


if 'min_sleep' in config_dict:
    min_sleep = string_to_float_convert_test(
        config_dict['min_sleep'])
    if min_sleep is None:
        errprint('Invalid min_sleep value, not float\nExit')
        exit(1)
    if min_sleep <= 0:
        errprint('min_sleep must be positive number\nExit')
        exit(1)
else:
    errprint('min_sleep is not in config\nExit')
    exit(1)


if 'over_sleep' in config_dict:
    over_sleep = string_to_float_convert_test(
        config_dict['over_sleep'])
    if over_sleep is None:
        errprint('Invalid over_sleep value, not float\nExit')
        exit(1)
    if over_sleep <= 0:
        errprint('over_sleep must be positive number\nExit')
        exit(1)
else:
    errprint('over_sleep is not in config\nExit')
    exit(1)


sensitivity_test_time = over_sleep / 2


if max_sleep < min_sleep:
    errprint('min_sleep value must not exceed max_sleep value.\nExit')
    exit(1)


if min_sleep < over_sleep:
    errprint('over_sleep value must not exceed min_sleep value.\nExit')
    exit(1)


if max_sleep == min_sleep:
    stable_sleep = True
else:
    stable_sleep = False


if print_proc_table_flag:

    if not root:
        log('WARNING: effective UID != 0; euid={}; processes with other e'
            'uids will be invisible for nohang'.format(self_uid))

    func_print_proc_table()


##########################################################################


if (low_memory_warnings_enabled or
    post_action_gui_notifications or
    check_warning_exe or
        soft_actions):

    import threading
    import shlex
    from subprocess import Popen, TimeoutExpired


psi_support = os.path.exists(psi_path)


##########################################################################

# Get KiB levels if it's possible.

soft_threshold_min_swap_tuple = get_swap_threshold_tuple(
    soft_threshold_min_swap)
hard_threshold_min_swap_tuple = get_swap_threshold_tuple(
    hard_threshold_min_swap)
warning_threshold_min_swap_tuple = get_swap_threshold_tuple(
    warning_threshold_min_swap)


swap_kb_dict = dict()

swap_term_is_percent = soft_threshold_min_swap_tuple[1]
if swap_term_is_percent:
    soft_threshold_min_swap_percent = soft_threshold_min_swap_tuple[0]
else:
    soft_threshold_min_swap_kb = soft_threshold_min_swap_tuple[0]
    swap_kb_dict['soft_threshold_min_swap_kb'] = soft_threshold_min_swap_kb

swap_kill_is_percent = hard_threshold_min_swap_tuple[1]
if swap_kill_is_percent:
    hard_threshold_min_swap_percent = hard_threshold_min_swap_tuple[0]
else:
    hard_threshold_min_swap_kb = hard_threshold_min_swap_tuple[0]
    swap_kb_dict['hard_threshold_min_swap_kb'] = hard_threshold_min_swap_kb


swap_warn_is_percent = warning_threshold_min_swap_tuple[1]
if swap_warn_is_percent:
    warning_threshold_min_swap_percent = warning_threshold_min_swap_tuple[0]
else:
    warning_threshold_min_swap_kb = warning_threshold_min_swap_tuple[0]
    swap_kb_dict['warning_threshold_min_swap_kb'
                 ] = warning_threshold_min_swap_kb


##########################################################################


if print_config_at_startup or check_config_flag:
    check_config()


##########################################################################


# for calculating the column width when printing mem and zram
mem_len = len(str(round(mem_total / 1024.0)))

if post_action_gui_notifications:
    notify_sig_dict = {SIGKILL: 'Killing',
                       SIGTERM: 'Terminating'}


# convert rates from MiB/s to KiB/s
fill_rate_mem = fill_rate_mem * 1024
fill_rate_swap = fill_rate_swap * 1024
fill_rate_zram = fill_rate_zram * 1024


warn_time_now = 0
warn_time_delta = 1000  # ?
warn_timer = 0


##########################################################################


if not root:
    log('WARNING: effective UID != 0; euid={}; processes with other e'
        'uids will be invisible for nohang'.format(self_uid))


# Try to lock all memory

mlockall()

##########################################################################


# print_self_rss()

psi_avg_string = ''  # will be overwritten if PSI monitoring enabled

mem_used_zram = 0


if print_mem_check_results:

    # to find delta mem
    wt2 = 0
    new_mem = 0

    # init mem report interval
    report0 = 0


# handle signals
for i in sig_list:
    signal(i, signal_handler)


psi_timestamp0 = monotonic()
psi_delta0 = 0


threshold = None
mem_info = None


CHECK_PSI = False
if psi_support and not ignore_psi:
    CHECK_PSI = True

hard_threshold_psi_exceeded_timer = 0
soft_threshold_psi_exceeded_timer = 0
psi_threshold = zram_threshold = zram_info = psi_info = None


CHECK_ZRAM = not ignore_zram

log('Monitoring has started!')

stdout.flush()


display_env = 'DISPLAY='
dbus_env = 'DBUS_SESSION_BUS_ADDRESS='
user_env = 'USER='

envd = dict()
envd['list_with_envs'] = envd['t'] = None


cmd_num_dict = dict()
cmd_num_dict['cmd_num'] = 0


m0 = monotonic()
pt0 = process_time()


##########################################################################










os.execvp('/bin/sleep', ['FOOOOOOO', '999'])
















